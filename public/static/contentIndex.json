{"index":{"title":"Welcome to My Scrolls","links":["ğŸ¥·ğŸ½-jutsus/ai","ğŸ¥·ğŸ½-jutsus/cloud-computing","ğŸ¥·ğŸ½-jutsus/databases","ğŸ¥·ğŸ½-jutsus/dsa","ğŸ¥·ğŸ½-jutsus/interview-prep","ğŸ¥·ğŸ½-jutsus/machine-learning","ğŸ¥·ğŸ½-jutsus/note-taking","ğŸ¥·ğŸ½-jutsus/personal-growth","ğŸ¥·ğŸ½-jutsus/software-dev","ğŸ¥·ğŸ½-jutsus/system-design","ğŸ¥·ğŸ½-jutsus/tools","ğŸ¥·ğŸ½-jutsus/SyncWise","ğŸ¥·ğŸ½-jutsus/dsa-mastery","ğŸ¥·ğŸ½-jutsus/interviews","ğŸ¥·ğŸ½-jutsus/project-kaizen","ğŸ¥·ğŸ½-jutsus/types-of-graph-edges","ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/two-pointers","ğŸ¥·ğŸ½-jutsus/arrays","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/tree-depth-traversals","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees","ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal","ğŸ¥·ğŸ½-jutsus/tree-depth-traversal-use-cases","ğŸ¥·ğŸ½-jutsus/tim-sort","ğŸ¥·ğŸ½-jutsus/searching--and--sorting","ğŸ¥·ğŸ½-jutsus/strings","ğŸ¥·ğŸ½-jutsus/stack","ğŸ¥·ğŸ½-jutsus/stability-of-sorting-algorithms"],"tags":[],"content":"\nMy name is Srikar V. I have always been a fan of these digital gardens, blogs I see online all beautifully structured and done. And to my shocking they were most of the time obsidian vaults. It always wondered me how they did it, and then I came across Quartz and Digital Garden which can help you render your obsidian notes as a static website. I was using Digital Garden which had good features, it could even render excalidraw drawings, mermaid etc, but I didnâ€™t like the UI, it was not to my taste. Even though it was the easiest to setup I didnâ€™t like it. So recently I moved to Quartz and damn it is good. If you are reading this then you are on the website rendered using Quartz. I have called it Scrolls because of the reference to Naruto where scrolls hold a lot of Jutsus.\n\n\nğŸ—ºï¸ Atlas\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateai2024-11-04 23:28cloud computing2024-11-04 23:48databases2024-11-05 02:16dsa2024-11-05 01:37interview prep2024-11-05 01:35machine learning2024-11-05 01:53note-taking2024-11-05 02:15personal growth2024-11-05 02:02software dev2024-11-05 02:04system design2024-11-05 02:15tools2024-11-05 02:17\n\nğŸ› ï¸ Projects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSyncWise2024-11-05 02:23dsa mastery2024-11-05 01:50interviews2024-11-05 02:38project kaizen2024-11-05 03:11\n\nğŸ†• Recent Notes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourceTagsStatustypes of graph edges2024-11-06 00:18graphszetteldsaliteraturetwo-pointers2024-11-06 00:17arrayszetteldsaliteraturetrees2024-11-06 00:16-zetteldsaliteraturetree depth traversals2024-11-06 00:15binary trees and binary search treeszetteldsaliteraturetree level order traversal2024-11-06 00:15binary trees and binary search treeszetteldsaliteraturetree depth traversal use cases2024-11-06 00:13tree depth traversalszetteldsaliteraturetim sort2024-11-06 00:12searching &amp; sortingzetteldsaliteraturestrings2024-11-06 00:11-zetteldsaliteraturestack2024-11-06 00:10-zetteldsaliteraturestability of sorting algorithms2024-11-06 00:09searching &amp; sortingzetteldsaliterature\n"},"ğŸ¥·ğŸ½-jutsus/1.-python":{"title":"1. python","links":["ğŸ¥·ğŸ½-jutsus/ai-roadmap"],"tags":["zettel","software-dev"],"content":"1. python\nResources\n\n\nPractical Python Programming | practical-python\nGitHub - dabeaz-course/python-mastery: Advanced Python Mastery (course by @dabeaz)\nJames Powellâ€™s Talks - YouTube\n\nSupplementary\n\n\nBook: Fluent Python, 2nd Edition\nPodcast: Talk Python To Me Podcast\n\n\nRelated Notes\nai roadmap\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/2.-python-design-patterns":{"title":"2. python design patterns","links":["ğŸ¥·ğŸ½-jutsus/ai-roadmap"],"tags":["zettel"],"content":"2. python design patterns\nResources\n\n\nDesign Patterns in Python\nPython Design Patterns\n\nProjects\n\n\nBuild your own Redis | CodeCrafters\nPython | CodeCrafters\n\n\nRelated Notes\nai roadmap\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/3.-data-analysis":{"title":"3. data analysis","links":[],"tags":["data-science"],"content":"Topics\n\n\npandas, numpy and matplotlib\nTableau\nSQL\n"},"ğŸ¥·ğŸ½-jutsus/4.-maths":{"title":"4. maths","links":[],"tags":["zettel","machine-learning"],"content":"4. maths\nResources\n\n\nLinear Algebra - Math for Machine Learning - YouTube\nedu/math-for-ml at main Â· wandb/edu Â· GitHub\nComputational Linear Algebra - YouTube\nGitHub - fastai/numerical-linear-algebra: Free online textbook of Jupyter notebooks for fast.ai Computational Linear Algebra course\nMathematics for Machine Learning - Linear Algebra - YouTube\nMathematics for Machine Learning - Multivariate Calculus - YouTube\nEssence of linear algebra - YouTube\nEssence of calculus - YouTube\nStatistics Fundamentals - YouTube\nInformation Theory\n\nSupplementary\n\n\nBook: Math for ML\nPaper: Matrix Calculus You Need for Deep Learning\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/5.-core-ml":{"title":"5. core ml","links":["03-resources/Books/StatQuest-Machine-Learning-Guide.pdf"],"tags":["zettel","machine-learning"],"content":"5. core ml\nResources\n\n\nNotion Page by Ayush Singh\nMachine Learning Course for Beginners - YouTube\nGitHub - ayush714/ML001-Project-Sources-Code-and-Learning-Materials: ML001 Sources Code and Learning Materials\nThe Hundred-Page Machine Learning Book by Andriy Burkov\nStatQuest Machine Learning Guide.pdf\n\nWrite from scratch\n\n\nGitHub - eriklindernoren/ML-From-Scratch: Machine Learning From Scratch. Bare bones NumPy implementations of machine learning models and algorithms with a focus on accessibility. Aims to cover everything from linear regression to deep learning.\nGitHub - JeremyNixon/oracle: Scratch Implementations of Major Machine Learning Algorithms\nGitHub - trekhleb/homemade-machine-learning: ğŸ¤– Python examples of popular machine learning algorithms with interactive Jupyter demos and math being explained\n\nCompete\n\n\nChallenges and Competitions | bitgrit\nKaggle: Your Machine Learning and Data Science Community\n\nDo Side Projects\n\n\nGetting machine learning to production | â˜…â¤âœ° Vicki Boykis â˜…â¤âœ°\nRetro on Viberary | â˜…â¤âœ° Vicki Boykis â˜…â¤âœ°\nGet a dataset and build a model (i.e., useÂ earthaccessÂ to get NASA Earth data).\nCreate a UI withÂ streamlitÂ and share it on Twitter.\n\nSupplementary\n\n\nMachine Learning with PyTorch and Scikit-Learn [Book]\nModel Evaluation, Model Selection, and Algorithm Selection in Machine Learning\nIntroduction to Machine Learning Interviews Book Â· MLIB\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/6.-mlops":{"title":"6. mlops","links":[],"tags":["zettel","machine-learning"],"content":"6. mlops\nResources\n\n\nHome - Made With ML\nGitHub - DataTalksClub/mlops-zoomcamp: Free MLOps course from DataTalks.Club\nGitHub - chiphuyen/machine-learning-systems-design: A booklet on machine learning systems design with exercises. NOT the repo for the book â€œDesigning Machine Learning Systemsâ€\nEvidently AI - ML system design: 450 case studies\nGitHub - stas00/ml-engineering: Machine Learning Engineering Open Book\nGitHub - zenml-io/zenml: ZenML ğŸ™: The bridge between ML and Ops. zenml.io.\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/7.-deep-learning":{"title":"7. deep learning","links":[],"tags":["ai","zettel"],"content":"Resources\n\n\nFastAI Part-1\nFastAI Part-2\nWeights &amp; Biases Study Group\nThe Full Stack Deep Learning\nyoutu.be/HJd1I3FdSnYÂ Ayush Singh YT\nLearn PyTorch for deep learning in a day. Literally. - YouTube\n\nBooks\n\n\nDive into Deep Learning â€” Dive into Deep Learning 1.0.3 documentation\nDeep Learning\nNeural networks and deep learning\nUnderstanding Deep Learning\nudlbook/Notebooks at main Â· udlbook/udlbook Â· GitHub\n\nReadÂ The Little Book of Deep LearningÂ on your phone instead of scrolling Twitter.\nRead these while your neural networks are converging.\n\nA Recipe for Training Neural Networks\nDeep Neural Nets: 33 years ago and 33 years from now\n\nMore Competitions\n\n\nPlantTraits2024 - FGVC11 | Kaggle\n\nImplement Papers\n\n\nAnnotated Research Paper Implementations: Transformers, StyleGAN, Stable Diffusion, DDPM/DDIM, LayerNorm, Nucleus Sampling and more\nBERT Explained | Papers With Code\n\n(Optional) Computer Vision\n\n\nStanford University CS231n: Deep Learning for Computer Vision\n\nReinforcement Learning\n\n\nWelcome to Spinning Up in Deep RL! â€” Spinning Up documentation\nWelcome to the ğŸ¤— Deep Reinforcement Learning Course - Hugging Face Deep RL Course\n\nNLP\n\n\nStanford CS 224N | Natural Language Processing with Deep Learning\nIntroduction - Hugging Face NLP Course\nThe Super Duper NLP Repo\n\nGood Articles &amp; Breakdowns\n\n\nBERT Research â€” Ep. 1 â€” Key Concepts &amp; Sources Â· Chris McCormick\nThe Illustrated Word2vec â€” Jay Alammar\nThe Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning\nUnderstanding LSTM Networks â€” colahâ€™s blog\nPyTorch RNN from Scratch â€” Jake Tae\n\nSupplementary\n\n\nNatural Language Processing with Transformers Book\n"},"ğŸ¥·ğŸ½-jutsus/8.-LLMs":{"title":"8. LLMs","links":[],"tags":["ai","zettel"],"content":"Resources\n\n\nIntro to Large Language Models - YouTube\nLarge Language Models in Five Formulas - YouTube\nNeural Networks: Zero To Hero\nGPT in 60 Lines of NumPy | Jay Mody\nLarge Language Models - YouTube\n\nFree LLM Bootcamp\n\n\nLLM Bootcamp - The Full Stack\n\nBuild with LLMs\n\n\nNeurIPS Tutorial Application Development using Large Language Models\nBuilding LLM applications for production\nPatterns for Building LLM-based Systems &amp; Products\nOpenAI Cookbook\nArtificial intelligence (AI) application templates and examples | Vercel â€“ Vercel\n\n\n\n                  \n                  Attention\n                  \n                \n\nThere is further resources left out. Please refer to this blog\n\n"},"ğŸ¥·ğŸ½-jutsus/GradeSync":{"title":"GradeSync","links":["ğŸ¥·ğŸ½-jutsus/SyncWise","features","ğŸ¥·ğŸ½-jutsus/gradesync-db-design","ğŸ¥·ğŸ½-jutsus/gradesync-architecture"],"tags":["documentation"],"content":"GradeSync\nPROJECT: SyncWise\nGradeSync\n\n\n                  \n                  Abstract\n                  \n                \n\nThis project proposes the development of a comprehensive web-based platform for analyzing and extracting results from Visvesvaraya Technological University (VTU). The platform is designed to facilitate teachers in managing student data, including batches, sections, and semesters, while providing insightful dashboards that visualize academic performance metrics across these categories. To streamline the previously manual process of result extraction, the system employs web scraping techniques coupled with CAPTCHA solving to automatically retrieve student results by sections. This data is stored in a centralised database, enabling real-time calculations of key performance indicators such as Semester Grade Point Average (SGPA) and overall percentage. \nIn addition to performance tracking, the platform will feature a predictive SGPA forecasting model and a risk indicator to identify students at risk of underperforming. A leaderboard will also be integrated to foster healthy competition among students by displaying their rankings based on academic performance. Both teachers and students will benefit from the platform; teachers will have access to detailed analytics for informed decision-making, while students can view their marks, monitor their performance against peers, and utilize forecasting tools to better understand their academic trajectory. This innovative solution aims to enhance educational outcomes by leveraging data analytics and automation, ultimately supporting both educators and learners in achieving academic excellence.\n\n\nFeatures\nTransclude of features#features-list\nTransclude of gradesync-db-design#db-design\nConflicts\n\nDatabase models clash between sqlalchemy and django-models\nStudent data clash from StudySync with GradeSyncâ€™s for login students DB table\n\nTransclude of gradesync-architecture#architecture"},"ğŸ¥·ğŸ½-jutsus/SyncWise":{"title":"SyncWise","links":[],"tags":["project","software-dev","machine-learning","ai"],"content":"SyncWise\n\n\n                  \n                  Abstract\n                  \n                \n\nAn integrated education platform for colleges (aka our college for now) that combines student performance analysis along with a doubt-resolution system. The dashboard enables teachers to manage batches, students, and performance metrics through a REST API built on FastAPI, while also providing students and teachers with personalised insights into their academic progress. Key features include performance visualisations, predictive analytics for semester forecasting, and an at-risk indicator for student assessments. Additionally, a chatbot powered by Retrieval-Augmented Generation (RAG) will assist students in resolving doubts, streamlining communication between students and teachers. If teh doubt is not resolved by the chatbot then the student can raise a ticket. This comprehensive solution enhances educational outcomes by leveraging data analytics and AI-driven support mechanisms.\n\n\nOverview\nTeam Members:\nMember-1: Srikar V Role: Data analysis, GradeSync backend, ML &amp; AI integration\nMember-2: Vignesh P Role: Frontend, ticketing system backend\nObjective: A comprehensive solution for managing results and student doubts.\nDeliverables:\nWebsite\nGradeSync:\n\nDashboards\nAnalytics\nRisk-Indicator\nForecasting\n\nStudy Sync\n\nDoubt-resolution chatbot\nTicketing System + chatting\nDeadline: 10-12-2024\nTimeline:\nStart date: 26-09-2024\nEnd date: NA\n\nTasks\npath includes 02-Projects/SyncWise\nnot done\nMilestones\nIdeas\n\nAdd pdf extraction too for results.\nForecasting model\nRisk-Indicator model\n Optimise the scraping to use multi-processing or threading etc.\n\nTech Stack\nBackend: Django, FastAPI\nFrontend: React, Tailwind CSS\nDatabase: Postgres, Vector DB\nRedis: Caching, Session Management, Scraping progress\nML Models: FastAPI\nChatbot: Vertex AI, langchain, langflow\nLinks &amp; References\nEduInsights + Ticketing System"},"ğŸ¥·ğŸ½-jutsus/acid-properties-in-dbms":{"title":"acid properties in dbms","links":[],"tags":["zettel","databases"],"content":"ACID Properties\nSummary\nACID properties refers to properties of transactions and its management in DBMS.\nTransaction: A single logical or atomic unit of work that accesses the DB and possibly modifies it. It uses read and write operations to access data in DBs.\n\nTasks\n\n Further exploration on ACID properties\n\n\nRelated Notes\nReferences(links)\nACID Properties in DBMS - GeeksforGeeks"},"ğŸ¥·ğŸ½-jutsus/adjacency-list-problems":{"title":"adjacency list problems","links":["Linked-List","ğŸ¥·ğŸ½-jutsus/graph-representations","ğŸ¥·ğŸ½-jutsus/graphs"],"tags":["zettel","dsa"],"content":"adjacency list problems\n\n\n                  \n                  Info\n                  \n                \n\nDegree of a vertex is the number of edges that it has or the number of neighbouring nodes it has.\n\n\nWhat can be the highest degree of a node? It would not be more than:\n(|V| - 1)\nbecause the potential neighbours a node can have is the number of vertices minus itself.\nSince in an adjacency list, each vertex has its neighbours as a Linked List, the maximum length of the Linked List will be:\n(|V| - 1)\nThis would make the access time equal to:\nO(d)\nwhere,\nd = degree of the vertex. d could be equal to:\n(|V| - 1)\n\n\n                  \n                  Caution\n                  \n                \n\nAnother problem is about the fact that directed graph representations would occupy O(E) while undirected graph representations would occupy O(2E). Just take up a example youâ€™ll realise.\n\n\n\nRelated Notes\ngraphs\ngraph representations\nReferences(links)\nFrom Theory To Practice: Representing Graphs | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/ai-roadmap":{"title":"ai roadmap","links":["1.-Python","2.-Python-Design-Patterns","3.-Data-Analaysis","4.-Mathematics","5.-Core-ML","6.-MLOps","7.-Deep-Learning","ğŸ¥·ğŸ½-jutsus/8.-LLMs"],"tags":["zettel","ai","machine-learning","data-science","software-dev"],"content":"ai roadmap\n\n\n                  \n                  Mindset\n                  \n                \n\nThere is only one way to success and that is the hard way. So if you are feeling comfortable with whatever you are doing then that just means there are 99% of other that are doing the same thing.\n\n\nMain RoadMap Flow\n\nMachine Learning Roadmap - by Ayush Singh [ Newera ]\nRoadmap to Learn AI in 2024. A free curriculum for hackers andâ€¦ | by Benedict Neo | bitgrit Data Science Publication | Medium\nAlso Consider this Course: CS50â€™s Introduction to Artificial Intelligence with Python\nCheck this out link too: GitHub - nivu/ai_all_resources: A curated list of Best Artificial Intelligence Resources\n\nSteps\n\nPython\n\n Learn core python\n Read/Finish supplementary material\n\n\nPython Design Patterns\n\n Learn patterns\n\n\nData Analysis\n\n Pandas, numpy and matplotlib\n Tableau\n SQL\n\n\nMathematics\n\n Linear Algebra\n Calculas\n Probability\n Information theory ( advanced topic)\n Read/Finish supplementary material\n\n\nCore ML\n\n Finish Ayush Singhâ€™s Notion page\n Ayush Singhâ€™s ML Tutorial\n Read 100 page book\n While reading implement the concepts from scratch\n Compete\n Do side projects\n Read/Finish supplementary material\n\n\nMLOps\n\n Finish MLOps Course\n ML System Design\n ML Engineering\n\n\nDeep Learning\n\n Finish the learning\n Read any one book from the list\n ReadÂ The Little Book of Deep LearningÂ on your phone instead of scrolling Twitter.\n Read the 2 blogs while the neural networks are converging\n Do more competitions\n Implement papers\n (Optional) Computer Vision\n Reinforcement Learning\n NLP\n Read the articles from the list\n Read/Finish supplementary material\n\n\nLLMs\n\n Watch Andrej Kaparthyâ€™s Intro to LLMs\n Watch LLMs in 5 formulas\n Watch Neural Networks: zero to hero by Andrej Kaparthy\n Finish the free LLM bootcamp\n Build with LLMs\n\n\n\n                  \n                   blog\n                  \n                \nThere is further resources left out. Please refer to this \n\n\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/ai":{"title":"ai","links":["ğŸ¥·ğŸ½-jutsus/attention-is-all-you-need","ğŸ¥·ğŸ½-jutsus/SyncWise","ğŸ¥·ğŸ½-jutsus/ml-advice-from-experts","ğŸ¥·ğŸ½-jutsus/7.-deep-learning","ğŸ¥·ğŸ½-jutsus/project-ideas","ğŸ¥·ğŸ½-jutsus/reserach-papers-to-implement","ğŸ¥·ğŸ½-jutsus/ai-roadmap","ğŸ¥·ğŸ½-jutsus/8.-LLMs"],"tags":["atlas"],"content":"AI\nResources\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourceattention is all you need2024-11-05 02:50-SyncWise2024-11-05 02:23-ml advice from experts2024-11-05 03:04-7. deep learning2024-11-04 23:34-project ideas2024-11-05 02:04-reserach papers to implement2024-11-05 02:10-ai roadmap2024-11-05 02:08-8. LLMs2024-11-04 23:46-\n"},"ğŸ¥·ğŸ½-jutsus/arrays":{"title":"arrays","links":["Sliding-Window","Two-Pointers","Binary-Search","Stack","Quick-Sort","Merge-Sort"],"tags":["zettel","dsa"],"content":"Arrays\nSummary\nArrays are a linear data structure, that can store a single type of datatype. It is a contagious datatype that allows for constant time retrieval.\nCommon Terms\n\nSubArray - It is a slice of an array. It has to follow the same order of elements, but it doesnâ€™t have to be the same length of original array.\n\n\n\n                  \n                  Example\n                  \n                \n\nFor the array [2, 3, 6, 1, 5, 4],Â [3, 6, 1]Â is a subarray whileÂ [3, 1, 5]Â is not a subarray.\n\n\n\nSubSequence - It is an sequence that follows the order of elements from left to right but not strictly and it is not a slice of the array.\n\n\n\n                  \n                  Example\n                  \n                \n\nFor the array [2, 3, 6, 1, 5, 4],Â [3, 1, 5]Â is a subsequence butÂ [3, 5, 1]Â is not a subsequence.\n\n\nTime Complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-ONoteAccessO(1)SearchO(n)Search (sorted array)O(log(n))InsertO(n)Insertion would require shifting all the subsequent elements to the right by one and that takes O(n)Insert (at the end)O(1)Special case of insertion where no other element needs to be shiftedRemoveO(n)Removal would require shifting all the subsequent elements to the left by one and that takes O(n)Remove (at the end)O(1)Special case of removal where no other element needs to be shifted\nTechniques\nSliding-Window\nTwo-Pointers\nTraversing from the right\nBinary Search if array is sorted/partially sorted\nPre-computation - prefix sum, postfix sum etc.\nTraversing array more than once - still O(N)\nQueue/Dequeue\nStack\nEssential Qs\n2Sum\nBest Time to Buy &amp; Sell Stock\nProduct of Array Except Self\nMaximum Subarray\nRecommended Qs\nMaximum Product Subarray\nSearch in Rotated Sorted Array\n3Sum\nContainer with Most Water\nSliding Window Maximum\nRelated Notes\nQuick Sort\nMerge Sort\nBinary Search\nTwo-Pointers\nSliding-Window\nReferences(links)\nArray cheatsheet for coding interviews | Tech Interview Handbook"},"ğŸ¥·ğŸ½-jutsus/attention-is-all-you-need":{"title":"attention is all you need","links":["03-resources/Research-Papers/Attention-Is-All-You-Need.pdf","cited-source-1","cited-source-2"],"tags":["zettel","ai"],"content":"Source Information:\n\nAuthor(s): Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, Illia Polosukhin\nTitle of Source: Attention Is All You Need\nPublication Information (e.g., Journal name, date): 2023\nLink: Attention Is All You Need\n\nAnnotations:\n\n\n                  \n                   Attention Is All You Need, p.1\n                  \n                \n\n\nThe dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder\n\n\n\n\n\n                  \n                   Attention Is All You Need, p.1\n                  \n                \n\n\nThe best performing models also connect the encoder and decoder through an attention mechanism\n\n\n\n                  \n                   Attention Is All You Need, p.1\nWe propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely.\n                  \n                \n\n\n\n                  \n                   Attention Is All You Need, p.1\nExperiments on two machine translation tasks show these models to be superior in quality while being more parallelizable and requiring significantly less time to train\n                  \n                \n\n\n\n\n\n                  \n                   Attention Is All You Need, p.1\n                  \n                \n\n\nOur model achieves 28.4 BLEU on the WMT 2014 Englishto-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU\n\n\n\n\n\n                  \n                   Attention Is All You Need, p.1\n                  \n                \n\n\nOn the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature.\n\n\n\n\n\n                  \n                   Attention Is All You Need, p.2\n                  \n                \n\n\nRecurrent models typically factor computation along the symbol positions of the input and output sequences. Aligning the positions to steps in computation time, they generate a sequence of hidden states ht, as a function of the previous hidden state htâˆ’1 and the input for position t. This inherently sequential nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.\n\n\n\n\n\n                  \n                   Attention Is All You Need, p.2\n                  \n                \n\n\nAttention mechanisms have become an integral part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences [ 2, 19 ]. In all but a few cases [ 27 ], however, such attention mechanisms are used in conjunction with a recurrent network.\n\nProblem statement that the paper suggests\n\n\n\n\n                  \n                   Attention Is All You Need, p.2\n                  \n                \n\n\nThe goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16 ], ByteNet [ 18 ] and ConvS2S [ 9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions. In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for ByteNet\n\nThe Actual Problem\n\n\n\n\n                  \n                   Attention Is All You Need, p.2\n                  \n                \n\n\nIn the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head\n\nImprovement the transformer is doing\n\n\n\n\n                  \n                   Attention Is All You Need, p.2\n                  \n                \n\n\nTo the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequencealigned RNNs or convolution\n\nTransformer uses self-attention completely\n\n\n\n\n                  \n                   Attention Is All You Need, p.2\n                  \n                \n\n\nMost competitive neural sequence transduction models have an encoder-decoder structure [  5,  2  ,  35]. Here, the encoder maps an input sequence of symbol representations  (x1, â€¦, xn)  to a sequence of continuous representations  z  = (z1, â€¦, zn).  Given  z, the decoder then generates an output sequence  (y1, â€¦, ym)  of symbols one element at a time. At each step the model is auto-regressive [10], consuming the previously generated symbols as additional input when generating\n\nEncoder-Decoder basics\n\n\n\nAttention Is All You Need, p.3\n\n\n                  \n                   Attention Is All You Need, p.3\n                  \n                \n\n\nThe encoder is composed of a stack of N = 6 identical layers. Each layer has two sub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, positionwise fully connected feed-forward network. We employ a residual connection [ 11 ] around each of the two sub-layers, followed by layer normalization [1]. That is, the output of each sub-layer is LayerNorm(x + Sublayer(x)), where Sublayer(x) is the function implemented by the sub-layer itself. To facilitate these residual connections, all sub-layers in the model, as well as the embedding layers, produce outputs of dimension dmodel = 51\n\nEncoder stack\n\n\n\n\n                  \n                   Attention Is All You Need, p.3\n                  \n                \n\n\nThe decoder is also composed of a stack of N = 6 identical layers. In addition to the two sub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head attention over the output of the encoder stack. Similar to the encoder, we employ residual connections around each of the sub-layers, followed by layer normalization. We also modify the self-attention sub-layer in the decoder stack to prevent positions from attending to subsequent positions. This masking, combined with fact that the output embeddings are offset by one position, ensures that the predictions for position i can depend only on the known outputs at positions less than i\n\nDecoder Stack\n\n\n\nAttention Is All You Need, p.4\n\n\n                  \n                   Attention Is All You Need, p.4\n                  \n                \n\n\nScaled Dot-Product Attenti\n\nRefer the heading - seems very complicated\n\n\n\nAttention Is All You Need, p.4\n\n\n                  \n                   Attention Is All You Need, p.4\n                  \n                \n\n\nMulti-Head Attentio\n\nRefer heading - seems very complicated\n\n\n\nAttention Is All You Need, p.5\n\n\n                  \n                   Attention Is All You Need, p.5\n                  \n                \n\n\nTransformer uses multi-head attention in three different ways:\n\nIn â€œencoder-decoder attentionâ€ layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder. This allows every position in the decoder to attend over all positions in the input sequence. This mimics the typical encoder-decoder attention mechanisms in sequence-to-sequence models such as [38, 2, 9].\nThe encoder contains self-attention layers. In a self-attention layer all of the keys, values and queries come from the same place, in this case, the output of the previous layer in the encoder. Each position in the encoder can attend to all positions in the previous layer of the encoder.\nSimilarly, self-attention layers in the decoder allow each position in the decoder to attend to all positions in the decoder up to and including that position. We need to prevent leftward information flow in the decoder to preserve the auto-regressive property. We implement this inside of scaled dot-product attention by masking out (setting to âˆ’âˆ) all values in the input of the softmax which correspond to illegal connec\n\n\nApplication of attention in the transformer architecture\n\n\nNew Terms:\n\nBLEU Score: Number between 0 and 1 for evaluating the quality of text which has been machine-translated from one language to another.\n\nQuotes (Optional):\nEvaluation:\n\nBriefly assess the credibility and usefulness of the source.\nIs the information reliable and unbiased?\nDoes it fit the scope of your research?\n\nFurther Exploration (Optional):\n\nJot down any questions raised by the source or areas youâ€™d like to investigate further.\nNote any references cited by the author that might be relevant to your research. cited-source-1 cited-source-2\n"},"ğŸ¥·ğŸ½-jutsus/aws-cloud-practitioner-resources":{"title":"aws cloud practitioner resources","links":[],"tags":["cloud-computing","zettel"],"content":"Course\n\n\n                  \n                  AWS Certified Cloud Practitioner Certification Course (CLF-C02) - Pass the Exam! \n                  \n                \n\nPrepare for the AWS Certified Cloud Practitioner Certification (CLF-C02) and pass!\nwww.youtube.com/watch\n\n\n\n\n                  \n                  Self-paced digital training on AWS - AWS Skill Builder \n                  \n                \n\nYour learning center to build in-demand cloud skills.\nexplore.skillbuilder.aws/learn/course/internal/view/elearning/134/aws-cloud-practitioner-essentials\n\n\n\n\n                  \n                  Self-paced digital training on AWS - AWS Skill Builder \n                  \n                \n\nYour learning center to build in-demand cloud skills.\nexplore.skillbuilder.aws/learn/course/internal/view/elearning/1990/aws-cloud-practitioner-essentials-core-services\n\n\nPractice Questions\n\n\n                  \n                  AWS Certification Real Exam Questions - Cloud Practitioner - PART 1 \n                  \n                \n\nThis video covers close to real exam questions that would help pass the AWS Cloud Practitioner certification exam.\nyoutu.be/IvvD13aNO68\n\n\n\n\n                  \n                  CLF-C02 Cloud Practitioner Certification Practice Questions 2024 : Part 1 \n                  \n                \n\nThe video covers practice exam questions that would help you pass the Cloud Practitioner certification CLF-C02 exam with ease.\nyoutu.be/bZzTMdFbgTs\n\n\nPractice Exams\n\n\n                  \n                  Info\n                  \n                \n\ngithub.com/kananinirav/AWS-Certified-Cloud-Practitioner-Notes/blob/master/practice-exam/exams.md\n\n"},"ğŸ¥·ğŸ½-jutsus/balanced-vs-unbalanced-trees":{"title":"balanced vs unbalanced trees","links":["03-resources/Mermaid-Diagrams/balanced-trees-mermaid","Linked-List","03-resources/Mermaid-Diagrams/unbalanced-trees","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees","ğŸ¥·ğŸ½-jutsus/tree-depth-traversals"],"tags":["zettel","dsa"],"content":"Balanced vs Unbalanced Trees\nBalanced vs Unbalanced\nBalanced Trees\nBalanced trees are a type of binary tree where the tree follows a rule that makes tree traversal efficient.\nRule: any binary tree is a balanced tree if the difference between the heights of left subtree and right subtree is at most 1.\nAccess:\n\\begin{gathered}\nO(log \\ n) \\\\\nlog \\ n = ~h \\\\\nh = height \\ of \\ tree\n\\end{gathered}\n\n\n                  \n                  Example\n                  \n                \n\nTransclude of balanced-trees-mermaid\n\n\n\nThe above tree is a balanced tree because the height difference between left and right subtree is exactly 1.\n\nUnbalanced Trees\nUnbalanced trees are the trees that donâ€™t follow the balanced rule and are usually skewed towards one side making it look like a Linked List which is a sequential data structure. Hence it defeats the use of having a tree.\nAccess:\n\\begin{gathered}\nO(n) \n\\end{gathered}\n\n\n                  \n                  Attention\n                  \n                \n\nThe drawback of unbalanced trees is the operations performed on them are costly due to their skewness and similarity to sequential data structures.\n\n\n\n\n                  \n                  Example\n                  \n                \n\nTransclude of unbalanced-trees\n\n\n\nRelated Notes\nbinary trees and binary search trees\ntree depth traversals\nLinked List\nReferences(links)\nGoogle"},"ğŸ¥·ğŸ½-jutsus/big-o-notation":{"title":"big-o notation","links":["Arrays","Binary-Search","Strings","Stack","Quick-Sort","Merge-Sort","Tim-Sort","ğŸ¥·ğŸ½-jutsus/trees","Trees","DSA-Mastery"],"tags":["zettel","dsa"],"content":"Big-O Notation\nSummary\nIs a notation that is used by programmers around the world to evaluate algorithms and compare time and space complexities.\nBig-O Notation denotes the worst case scenario of any algorithm.\nIt is denoted as O(â€¦) â†’ time or space complexity inside.\nRules\nThere are some rules to be followed when writing this notation.\nRule-1: Highest degree of the equation is only considered. (worst case)\n\n\n                  \n                  Example\n                  \n                \n\nO(n^2 + n.log n + n) becomes O(n^2)\n\n\nRule-2: Constants are ignored.\n\n\n                  \n                  Example\n                  \n                \n\nO(2n) or O(n/2) is equal to O(n) even though the first one is bigger.\n\n\nFamous Big-Oâ€™s\nThere are some Big-O time or space complexities that often appear in most of the algorithms or code we write.\n\nThe best one or the most fastest is O(1) while O(n!) is the slowest. When we write code we always try to write the algorithm with fastest time or space complexities and Big-O plays a good role to denote that.\nO(1)\nConstant time or space complexity.\n\n\n                  \n                  Example\n                  \n                \n\nArrays:\n\nlookup\npush to end\npop from end\n\nHashMap:\n\nlookup\ninsert\nremove\n\n\n\nO(log n)\nLogarithmic time or space complexity\nWhen input size decreases by half at each step, then the problem is O(log n).\n2^x = n , x is number of times the input size must be decreased by half to get single element. To find x we can apply log on both sides, x = log2 n\n\n\n                  \n                  Example\n                  \n                \n\n\nBinary Search\nHeap:\n\npush\npop\n\n\n\n\n\nO(n)\nLinear time or space complexity.\nThe most common time complexity when dealing with Arrays or Strings.\n\n\n                  \n                  Example\n                  \n                \n\n\nLooping\nLinear Search\nBuild Heap\nMonotonic Stack or Sliding Window\n\n\n\nO(sqrt(n))\nNot very common complexity\n\n\n                  \n                  Example\n                  \n                \n\nFinding all factors of n\n\n\nO(n^2)\nSquared time or space complexity.\nOccurs when we loop through the 1d array for every single element in the 1d array which makes it n * n times.\nAlso common when traversing a 2d array or matrix and some sorting algorithms on 1d array.\n\n\n                  \n                  Example\n                  \n                \n\n\nTraverse a matrix\nPair of elements in array\nInsertion, Bubble, Selection Sort\n\n\n\nO(n.log n)\nLinear log time or space complexity\nlog n occurs when we decrease the input size by half at each step, if this single step is applied n times then it becomes O(n.log n).\n\n\n                  \n                  Example\n                  \n                \n\n\nHeap Sort\nQuick Sort\nMerge Sort\nTim Sort\n\n\n\nO(2^n)\nThe complexity where at each step the input size increases by progressive power of 2.\nBinary trees like recursion or backtracking.\n\n\n                  \n                  Example\n                  \n                \n\n\nBinary Trees\n\n\nO(c^n)\nThe complexity where at each step the input size increases by progressive power of c.\nTrees with more than 2 child nodes at each step in recursion or backtracking.\nO(n!)\nThe worst possible time or space complexity.\n\n\n                  \n                  Example\n                  \n                \n\n\nPermutations\nTravelling Salesman Problem\n\n\n\n\nKey Terms\nTime Complexity: refers to an equation that denotes the runtime of an algorithm.\nSpace Complexity: refers to an equation that denotes the extra space or memory used by an algorithm.\nRelated Notes\nDSA Mastery\nReferences(links)\nBig-O Notation - For Coding Interviews - YouTube\nNeetCode Big-O Notation"},"ğŸ¥·ğŸ½-jutsus/binary-insertion-sort":{"title":"binary insertion sort","links":["Tim-Sort","Binary-Search"],"tags":["zettel","dsa"],"content":"Binary Insertion Sort\nSummary\nBinary Insertion Sort is an essential part of Tim Sort and that is the reason why I came across it while learning Tim Sort.\nAs the name suggests it is a combination of Binary Search and insertion sort.\nIdea\nSince we know Binary Search takes O(log n) time to execute. This Sorting algo takes that to advantage by using it to find the right index at which the new element should be so that insertion sort can be used to insert the element at that index and the following elements are pushed.\nIn insertion sort alone, the algorithm finds the right index by comparing each element which takes more time and expensive operations.\nSteps\n\nIf the elements are already in increasing order it will keep going forward until it finds an element that violates it.\nUse binary search to find the right index at which the violating element should be present since we know the elements previous to violating element are sorted.\nNow use insertion sort to insert the violating element at that index and push the following elements forward.\n\n\n\nRelated Notes\nTim Sort\nBinary Search\nReferences(links)\nThe FASTEST sorting algorithm: Part 2 - Binary Insertion Sort - YouTube"},"ğŸ¥·ğŸ½-jutsus/binary-search":{"title":"binary search","links":["Arrays"],"tags":["zettel","dsa"],"content":"Binary Search\nSummary\nSearch sorted array\nAt every step the search space becomes half making it efficient for searching in sorted array\nThis Algo can be used not only for searching sorted Arrays but also whenever a binary decision has to be made to shrink search space.\nComplexity\nTime Complexity: O(log n)\nSpace Complexity: O(1)\nVanilla Binary Search\nOriginal implementation of binary search\nfrom typing import List\n \ndef binary_search(arr: List[int], target: int) -&gt; int:\n\tleft, right = 0, len(arr) - 1\n\twhile left &lt;= right:\n\t\tmid = (left + right) // 2\n\t\tif arr[mid] &gt; target:\n\t\t\tright = mid - 1\n\t\telif arr[mid] &lt; target:\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\treturn mid+1\n\treturn -1 \n \narr: List[int] = [23, 45, 46, 67, 88]\ntarget = int(input(&quot;Enter target: &quot;))\nprint(&quot;Index: &quot;, binary_search(arr, target))\nMod Binary Search\nIt is a binary search that can be used for mods with different conditions rather than a simple search.\ndef binary_search(arr: List[int], target: int) -&gt; int:\n\tleft, right = 0, len(arr) - 1\n\tindex = -1 \n\twhile left &lt;= right:\n\t\tmid = (left + right) // 2\n\t\tif feasible(mid):\n\t\t\tindex = mid\n\t\t\tright = mid - 1\n\t\telse:\n\t\t\tleft = mid + 1\n\treturn index\nQuestions\nCan binary search be modified for different use cases that involve binary decisions? A: Yes\nRelated Notes\nArrays\nReferences(links)\nVanilla Binary Search\nFirst True in a Sorted Boolean Array"},"ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees":{"title":"binary trees and binary search trees","links":["ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/tree-depth-traversals","ğŸ¥·ğŸ½-jutsus/tree-depth-traversal-use-cases","Searching--and--Sorting","ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal"],"tags":["zettel","dsa"],"content":"Binary Trees and BSTs\nSummary\nEach node except the root node in a binary tree contains: left subtree and right subtree. A searchable binary tree is a binary search tree.\n\nComplete Binary tree: a binary tree in which every level, except the last is completely filled and all nodes in the last level are as far left as possible.\nBalanced Binary tree: a binary tree in which the left and right subtree of every node doesnâ€™t differ in height by no more than 1.\n\n\n                  \n                  Node\n                  \n                \n\nclass Node:\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.left = None\n\t\tself.right = None\n\n\n\nBinary Search Trees\nThese trees are a special case of binary trees where each node follows a rule.\n\nRule: left node is lesser than current node and right node is greater.\n\n\n\n\n                  \n                  Info\n                  \n                \n\nIn-order traversal of a BST will give the elements in order.\n\n\n\n\n                  \n                  Time\n                  \n                \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-OAccessO(log(n))SearchO(log(n))InsertO(log(n))RemoveO(log(n))\n\n\n\n\n                  \n                  Important\n                  \n                \n\nSpace complexity of traversing a balanced binary tree would O(h), where â€˜hâ€™ is the height of the tree.\nSpace Complexity of traversing a BST would be O(log n).\nSpace Complexity of traversing a skewed binary tree or BST would be O(n).\n\n\n\nRelated Notes\ntrees\ntree depth traversals\ntree depth traversal use cases\nSearching &amp; Sorting\ntree level order traversal\nReferences(links)\nLeaf It Up To Binary Trees. Most things in software can be brokenâ€¦ | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/bookshelf":{"title":"bookshelf","links":["04-Atlas/DSA"],"tags":["zettel","personal-growth","software-dev","machine-learning"],"content":"bookshelf\nGeneral\n\nThe Book of five rings\nEleanor and Park\n\nMoney\n\nRich Dad Poor Dad\n\n\nDSA\n\nCoding Interview\nGrokking Algorithms (Beginner) - amzn.to/2JcBrjS\nIntroduction to Algorithms (Advanced) - amzn.to/2V03JRb\n\nBest Practices\n\nRefactoring - amzn.to/42NOY60\n\nDistributed Systems\n\nUnderstanding Distributed Systems (Beginner) - amzn.to/3cjChr5\nDesigning Data Intensive Applications (Advanced) - amzn.to/3fxgOLm\n\nData Science\n\nThe Signal and the Noise - amzn.to/4bKXKWs\nThe Art of Statistics - amzn.to/3OR9dda\n\nMachineLearning\n\n100-page ML Book - amzn.to/4bKXOWc\nDeep Learning Book (FREE) - www.deeplearningbook.org\nDesigning ML Systems - amzn.to/3wA48zy\n\nCase Studies\n\nSoftware Architecture: The Hard Parts - amzn.to/3XTHQ4g\nSoftware Engineering at Google - amzn.to/4bKcCV6\n\nEngineering Management\n\nEngineering Management for the Rest of Us - amzn.to/3JanteZ\n\nProductivity\n\nDeep Work - amzn.to/44jy8LZ\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/bubble-sort":{"title":"bubble sort","links":["Arrays","Searching--and--Sorting"],"tags":["zettel","dsa"],"content":"Bubble Sort\nCaptures\nIt is one of the most common sorting techniques that is taught first when you are learning about sorting. It is also the most intuitive and simple way that comes to mind when you think of sorting.\nIn bubble sort, we check the i and i+1 element in an Arrays to see if it in the order (ascending or descending) and swap it if it is not in order.\n[5, 4, 1, 2, 3]\nwe swap 5 and 4 because there are not in ascending order. \n\nWe need to repeat this process of checking neighbour elements for a maximum of the Arrays size.\nEvery time we finish one iteration the greatest element in the array (for ascending) will be put in its position which is the last index. So every iteration the array gets sorted from the end and hence we need n iterations if there are n elements to sort.\nYou may not need n iterations for every Arrays because sometimes an Arrays is sorted partially and this helps the algorithm sort the whole Arrays way earlier. We can detect this by checking if there was any swap in the inner loop while checking neighbouring elements. If there was no swaps then that means that the Arrays is sorted.\nCode\ndef bubble(arr):\n\tfor i in range(n):\n\t\tswapped = False # to check if arr is sorted early on.\n\t\tfor j in range(n-i-1): # not consider the elements at the end that got sorted.\n\t\t\tif arr[j] &gt; arr[j+1]:\n\t\t\t\tswapped = True\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\tif not swapped:\n\t\t\tbreak # array is sorted early on.\n \narr = [5, 4, 1, 2, 3] # sorted: [1, 2, 3, 4, 5]\nbubble(arr)\n\nRelated Notes\nArrays\nSearching &amp; Sorting\nReferences(links)\ngfg"},"ğŸ¥·ğŸ½-jutsus/chaining":{"title":"chaining","links":["ğŸ¥·ğŸ½-jutsus/hash-tables","ğŸ¥·ğŸ½-jutsus/linear-probing","Linked-List","ğŸ¥·ğŸ½-jutsus/hash-functions","Arrays"],"tags":["zettel","dsa"],"content":"Chaining\nSummary\nChaining is a collision resolution tactic used in hash tables. It is a closed addressing tactic. Unlike linear probing which utilises the other buckets if there is a collision, chaining ==implements a Linked List at the collision bucket to store the collisions==.\nWhen there is a collision with the bucket computed by the hash functions, this method uses a Linked List at the collision bucket to store the collision values.\n\nProblems\nLinear Search Time: if most of the values belong to a single bucket then the search for a value becomes equal to or close to linear time, which defeats the reason of having a hash tables\nUse chaining when we have a ==well-defined hash functions that distributes the values uniformly== making the search time average out to constant time.\n\nRelated Notes\nhash tables\nhash functions\nlinear probing\nArrays\nLinked List\nReferences(links)\nHash Table (Closed Addressing: Separate Chaining and Open Addressing: Linear Probing, Quadratic Probing, Double Hashing) - VisuAlgo"},"ğŸ¥·ğŸ½-jutsus/cloud-computing":{"title":"cloud computing","links":["ğŸ¥·ğŸ½-jutsus/aws-cloud-practitioner-resources"],"tags":["atlas"],"content":"cloud computing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourceaws cloud practitioner resources2024-11-04 23:50-\n"},"ğŸ¥·ğŸ½-jutsus/cyclic-and-acyclic-graphs":{"title":"cyclic and acyclic graphs","links":["ğŸ¥·ğŸ½-jutsus/graphs"],"tags":["zettel","dsa"],"content":"Cyclic and Acyclic graphs\nCaptures\nWe have directed and undirected graphs and these graphs could also be cyclic or acyclic graphs.\nCyclic: graphs that have at least one single cycle i.e edges that allow traversal of the nodes in a circular fashion.\ngraph LR;\n\tA --- B\n\tB --- D\n\tB --- C\n\tC --- A\n\tD --- X\n\nAcyclic: graphs that have no cycles at all i.e the edges donâ€™t allow traversal of the nodes in a circular fashion.\ngraph LR;\n\tA --- B\n\tA --- C\n\tC --- D\n\tB --- E\n\tB --- F\n\nSelf-loops can only occur in directed graphs and they are considered cyclic because it forms a cycle with itself.\ngraph LR;\n\tA --&gt; B\n\tA --&gt; C\n\tB --&gt; D\n\tD --&gt; D\n\tC --&gt; E\n\tA --&gt; E\n\nSince directed graphs are very important and most of the data in this world are mostly directed. We have much importance in:\n\nDirected Cyclic Graphs\nDirected Acyclic Graphs (DAG) *\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/data-science":{"title":"data science","links":[],"tags":[],"content":"data science\nTABLE\n\tdate as &quot;Date&quot;,\n\tsources as &quot;Source&quot;\nFROM &quot;content/ğŸ¥·ğŸ½ jutsus&quot;\nWHERE atlas = [[data science]]"},"ğŸ¥·ğŸ½-jutsus/databases":{"title":"databases","links":["ğŸ¥·ğŸ½-jutsus/joins-in-sql","ğŸ¥·ğŸ½-jutsus/acid-properties-in-dbms","ğŸ¥·ğŸ½-jutsus/db-normalization"],"tags":["atlas"],"content":"databases\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourcejoins in sql2024-11-05 23:54-acid properties in dbms2024-11-05 23:32-db normalization2024-11-05 23:49-\n"},"ğŸ¥·ğŸ½-jutsus/db-normalization":{"title":"db normalization","links":[],"tags":["zettel","databases"],"content":"DB Normalization\nSummary\nNormalization is the process of minimising redundancy in relations or a set of relations. Redundancy in relations can cause insert, delete and update anomalies. The same concept is used in databases with a set of rules or forms to follow.\nNormal Forms\nFirst Normal Form - 1NF: each table cell must contain only single value and each column name must be unique.\nSecond Normal Form - 2NF: each non-key attribute is dependent on the primary key.\nThird Normal Form - 3NF: all non-key attribute but be independent of each other.\nBoyce-Codd Normal Form - BCNF: stricter form of 3NF, states that each non-key attribute be dependent only on the candidate key.\nFourth Normal Form - 4NF: ensures that the table doesnâ€™t contain any multi-valued dependencies.\nFifth Normal Form - 5NF: decomposing table into smaller tables to remove data redundancy and ensure data integrity\nTasks\n\n Further exploration on DB Normalization\n\n\nQuestions\nQ: Difference between 2NF, 3NF and BCNF?\nKey Terms\nRelated Notes\nReferences(links)\nNormal Forms in DBMS - GeeksforGeeks"},"ğŸ¥·ğŸ½-jutsus/dependency-graphs":{"title":"dependency graphs","links":["ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs","ğŸ¥·ğŸ½-jutsus/dependency-graphs","ğŸ¥·ğŸ½-jutsus/topological-sorting"],"tags":["zettel","dsa"],"content":"dependency graphs\nDependency graphs are essentially directed acyclic graphs that helps resolve dependencies for any package. Package managers like npm or yarn use directed acyclic graphs for resolving their dependencies.\nDependency graphs can be confusing but with the below example it is easy to understand.\ngraph LR;\n\tA --&gt; B\n\tA --&gt; C\n\tB --&gt; D\n\nFrom the above graph, we can say that:\n\nA is dependent on B and C. B is dependent on D.\n\nThe above statement might seem confusing if you take the literal meaning of the directed edges. But what this means in dependency graphs is that before we install the dependency A, dependencies B and C must be installed and before we install the dependency B, dependency D must be installed.\nThis ultimately resolves dependency issues.\nQ: If we do topological sorting on a dependency graph we essentially get the reverse order in which we have resolve the dependencies. Is that right? Why is it that way?\nA:\n\nRelated Notes\ndirected acyclic graphs\ngraphs\ntopological sorting\nReferences(links)\nSpinning Around In Cycles With Directed Acyclic Graphs | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/desexualizing-your-brain-is-the-cheat-code-to-success":{"title":"desexualizing your brain is the cheat code to success","links":[],"tags":["zettel","personal-growth"],"content":"desexualizing your brain is the cheat code to success\n00:07\nEvery single day you are frying your brain, killing attention span, killing your focus.\n00:46\nSelf-Discipline and Self-Control the things without which you canâ€™t be successful, you are just fooling yourself\n01:31\nStep-1: Stop fucking watching p***.\nFries up your brain which leads to the erosion of the part of brain that is responsible for emotions, motivation and actions. Your brain has been rewired to be aroused by watching others do the deed rather than yourself.\n03:29\nStep-2: Stop pleasuring yourself.\nCheap Dopamine. You are telling your brain that youâ€™ve done what you have been evolutionary been told to do â†’ procreate. The brain gives a high dopamine peak due to this which makes it unable to focus or do hard work.\nP*** and masturbation gives a dopamine spike of 250% which is higher than fast food or drugs.\n06:09\nStep-3: Find your purpose.\n08:06\nStep-4: Stop Watching Soft Porn.\nHelps you get rid of the triggers that lead you to watch p***.\n09:20\nStep-5: Focus Inward and Not Outward.\nDopamine Detoxâ€¦ Stop seeking cheap dopamine outwards(i.e p***, parties, foodâ€¦) and start seeking it inwards(i.e delayed gratification, hard work, goalsâ€¦)\n11:12\nStep-6: Stop Chasing Women.\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/dfs-and-cycles-in-graphs":{"title":"dfs and cycles in graphs","links":["ğŸ¥·ğŸ½-jutsus/cyclic-and-acyclic-graphs","ğŸ¥·ğŸ½-jutsus/graphs","Recursion","ğŸ¥·ğŸ½-jutsus/graphs-depth-first-search","ğŸ¥·ğŸ½-jutsus/types-of-graph-edges","Stack"],"tags":["zettel","dsa"],"content":"DFS and Cycles\nCaptures\nWe are aware of cyclic and acyclic graphs and they play an important role when we are traversing graphs.\nThe Recursion working of graphs depth first search, makes it a powerful tool to detect cycles.\nWhy is that?\nWe know from types of graph edges that back edges occur when a node in a tree path links to one of its ancestors. And back edges are essentially edges that form a cycle in graphs.\ngraph LR;\n\tU --&gt; V\n\tV --&gt; X\n\tX --&gt; Y\n\tY --&gt; V\n\nSince graphs depth first search maintains a Stack as it follows a path, if at any level there is a node that links to a node that is already in the stack (essentially in the path) then we know this link forms a cycle.\n\nFrom the above diagram of the stack we can see how graphs depth first search detects cycle. Itâ€™s innate nature of following a path in Recursion makes it efficient to detect back edges, which are the edges that form a cycle.\n\nRelated Notes\ngraphs depth first search\ntypes of graph edges\ngraphs\nRecursion\nStack\nReferences(links)\nSpinning Around In Cycles With Directed Acyclic Graphs | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs":{"title":"directed acyclic graphs","links":["ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/dependency-graphs","ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs","ğŸ¥·ğŸ½-jutsus/topological-sorting","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/graphs-depth-first-search","ğŸ¥·ğŸ½-jutsus/cyclic-and-acyclic-graphs"],"tags":["zettel","dsa"],"content":"DAG\nDAG stands for Directed Acyclic Graphs, as the name suggests these are a type of graph that has directed edges and doesnâ€™t contain any cycles.\ngraph LR;\n\ta --&gt; c\n\tb --&gt; d\n\tc --&gt; e\n\tc --&gt; f\n\tc --&gt; d\n\td --&gt; f\n\te --&gt; f\n\tf --&gt; g\n\nIf youâ€™ve noticed in the above graphs, the nodes have some kind of ordering. And this ordering is the reason why DAGs are famous and pretty common.\nThey have many use cases:\n\nScheduling tasks which need to be processed in an order.\nTo represent state machines for objects that donâ€™t have reversible states.\ndependency graphs are DAGs\n\nSince directed acyclic graphs have a specific ordering, this means we need an algorithm to sort through and order the nodes. This is where topological sorting comes.\ntrees are naturally directed acyclic graphs since they donâ€™t have cycles and are actually undirected (but in perspective of CS it is considered directed).\n\nRelated Notes\ngraphs\ntrees\ngraphs depth first search\ncyclic and acyclic graphs\ntopological sorting\ndependency graphs\nReferences(links)\nSpinning Around In Cycles With Directed Acyclic Graphs | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/django-rest-framework":{"title":"django-rest-framework","links":[],"tags":["zettel","software-dev"],"content":"django-rest-framework\nSteps\nStep-1: create python env\npython -m venv .venv\n\nStep-2: activate environment\n# Mac OS\nsource .venv/bin/activate  \n\nStep-3: install libraries\npip install django djangorestframework environs\n\nStep-4: freeze it to requirements.txt\npip freeze &gt; requirements.txt\n\nStep-5: create a django project\ndjango-admin startproject &lt;myproject&gt;\n\nStep-6: change dir into the project\ncd &lt;myproject&gt;\n\nStep-7: create an app for the api\npython manage.py startapp api\n\nStep-8: update settings.py\nINSTALLED_APPS = [\n    &quot;django.contrib.admin&quot;,\n    &quot;django.contrib.auth&quot;,\n    &quot;django.contrib.contenttypes&quot;,\n    &quot;django.contrib.sessions&quot;,\n    &quot;django.contrib.messages&quot;,\n    &quot;django.contrib.staticfiles&quot;,\n    &quot;api&quot;,\n    &quot;rest_framework&quot;,\n]\nStep-9: add models to models.py\nfrom django.db import models\n \n# Create your models here.\nclass BlogPost(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    published_date = models.DateTimeField(auto_now_add=True)\n    \n    def __str__(self):\n        return self.title\nStep-10: create serializers.py inside the api dir and add the below code\nfrom rest_framework import serializers\nfrom .models import BlogPost\n \nclass BlogPostSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = BlogPost\n        fields = &quot;__all__&quot;\n\n\n                  \n                  Note\n                  \n                \n\nWe create a serializer because we need to convert the model to json objects to be returned or passed to API endpoints that we create.\n\n\nStep-11: create views you can use the generic views for create, read, update and delete.\nStep-12: add urls.py file inside the app\nfrom django.urls import path\nfrom . import views\n \nurlpatterns = [\n    path(&quot;blogposts/&quot;, views.BlogPostListCreate.as_view(), name=&quot;blog-post-list-create&quot;),\n]\nStep-13: update the urls.py in our project to forward to appâ€™s url.\nfrom django.urls import path, include\n \nurlpatterns = [\n    path(&quot;&quot;, include(&quot;api.urls&quot;)),\n]\nStep-14: make migrations\n# make sure you are inside your project\npython manage.py makemigrations\n\nStep-15: migrate\npython manage.py migrate \n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/dsa-mastery":{"title":"dsa mastery","links":["ğŸ¥·ğŸ½-jutsus/dsa","Arrays","Strings","ğŸ¥·ğŸ½-jutsus/hash-tables","Searching--and--Sorting","Matrix","Linked-List","Queue","Stack","Merge-Sort","Quick-Sort"],"tags":["project","dsa","interview-prep"],"content":"DSA Mastery\nOverview\n\nObjective:\n\nLearn core concepts of dsa\nPractice leetcode problems\n\n\nDeliverables:\n\nUnderstanding of dsa concepts\nSolving dsa problems efficiently\n\n\nDeadline:\n\n20 Oct 2024\n\n\n\nTasks\n\n Learn the core concepts - Solve only essential Qs\n\n Basic\n\n Arrays\n Strings\n hash tables\n Recursion\n Searching &amp; Sorting\n\n\n Data Structures\n\n Matrix\n Linked List\n Queue\n Stack âœ… 2024-09-24\n Interval\n\n\n Advanced Data Structures\n\n Tree âœ… 2024-10-03\n Graph âœ… 2024-10-24\n Heap\n Trie\n\n\n Additional\n\n Dynamic Programming\n Binary\n Math\n Geometry\n\n\n\n\n generate flashcards for each topic\n Solve the recommended Qs in the core concepts\n Solve the Qs in the Grind 75 plan\n\nMilestones\n\nMilestone 1: Finished Arrays Essential &amp; Recommended Qs 2024-08-29\nMilestone 2: Finished Strings Essential Qs 2024-09-01\n\n\nNotes\n\nInitially I thought Merge Sort is better than Quick Sort, but when Arrays are concerned Quick Sort is better.\nRemove redundant operations in your code Idiot!!.\nMake sure you test out edge cases even before you submit the code, donâ€™t keep adjusting your code every time you get a edge case wrong.\n\nLinks &amp; References\nThe Ultimate LeetCode Flowchart: Solve Any Coding Problem Systematically\nCoding Interviews Patterns\nCoding interview study plan - what to study and practice based on time left | Tech Interview Handbook\nGrind 75 - A better Blind 75 you can customize, by the author of Blind 75\nCompanies-problems: GitHub - xizhengszhang/Leetcode_company_frequency: Collection of leetcode company tag problems. Periodically updating."},"ğŸ¥·ğŸ½-jutsus/dsa":{"title":"dsa","links":["ğŸ¥·ğŸ½-jutsus/big-o-notation","ğŸ¥·ğŸ½-jutsus/stack","ğŸ¥·ğŸ½-jutsus/cyclic-and-acyclic-graphs","ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/dsa-mastery","ğŸ¥·ğŸ½-jutsus/level-order-traversal-by-level-dry-run","ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal","ğŸ¥·ğŸ½-jutsus/dfs-and-cycles-in-graphs","ğŸ¥·ğŸ½-jutsus/graphs-depth-first-search","ğŸ¥·ğŸ½-jutsus/arrays","ğŸ¥·ğŸ½-jutsus/types-of-graph-edges","ğŸ¥·ğŸ½-jutsus/level-order-traversal-dry-run","ğŸ¥·ğŸ½-jutsus/recursion","ğŸ¥·ğŸ½-jutsus/binary-search","ğŸ¥·ğŸ½-jutsus/graphs-breadth-first-search","ğŸ¥·ğŸ½-jutsus/tree-depth-traversal-use-cases","ğŸ¥·ğŸ½-jutsus/tree-depth-traversals","ğŸ¥·ğŸ½-jutsus/merge-sort","ğŸ¥·ğŸ½-jutsus/sliding-window","ğŸ¥·ğŸ½-jutsus/two-pointers","ğŸ¥·ğŸ½-jutsus/topological-sorting-using-dfs","ğŸ¥·ğŸ½-jutsus/topological-sorting","ğŸ¥·ğŸ½-jutsus/dependency-graphs","ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs","ğŸ¥·ğŸ½-jutsus/adjacency-list-problems","ğŸ¥·ğŸ½-jutsus/graph-representations","ğŸ¥·ğŸ½-jutsus/chaining","ğŸ¥·ğŸ½-jutsus/hash-functions","ğŸ¥·ğŸ½-jutsus/hash-tables","ğŸ¥·ğŸ½-jutsus/stability-of-sorting-algorithms","ğŸ¥·ğŸ½-jutsus/searching--and--sorting","ğŸ¥·ğŸ½-jutsus/essential-python-built-ins","ğŸ¥·ğŸ½-jutsus/binary-insertion-sort","ğŸ¥·ğŸ½-jutsus/tim-sort","ğŸ¥·ğŸ½-jutsus/types-of-trees","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/matrix","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees","ğŸ¥·ğŸ½-jutsus/linear-probing","ğŸ¥·ğŸ½-jutsus/topological-sorting-using-khan's-algo","ğŸ¥·ğŸ½-jutsus/queue","ğŸ¥·ğŸ½-jutsus/linked-list","ğŸ¥·ğŸ½-jutsus/quick-sort"],"tags":["atlas"],"content":"dsa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourcebig-o notation2024-11-05 23:35-stack2024-11-06 00:10-cyclic and acyclic graphs2024-11-05 23:49graphsdsa mastery2024-11-05 01:50-level order traversal by level dry run2024-11-05 23:55tree level order traversaldfs and cycles in graphs2024-11-05 23:50graphs depth first searchcyclic and acyclic graphsarrays2024-11-05 23:33-graphs2024-11-05 03:07-types of graph edges2024-11-06 00:18graphslevel order traversal dry run2024-11-05 23:56tree level order traversalrecursion2024-11-06 00:06-binary search2024-11-05 23:45arraysgraphs breadth first search2024-11-05 23:51graphstree depth traversal use cases2024-11-06 00:13tree depth traversalsmerge sort2024-11-06 00:02arrayssliding window2024-11-06 00:08arraystwo-pointers2024-11-06 00:17arraystopological sorting using dfs2024-11-05 23:28topological sortingdependency graphs2024-11-05 23:29directed acyclic graphsadjacency list problems2024-11-05 23:33graph representationschaining2024-11-05 23:48hash functionshash tables2024-11-05 23:54-stability of sorting algorithms2024-11-06 00:09searching &amp; sortingessential python built-ins2024-11-05 01:43-binary insertion sort2024-11-05 23:44tim sorttypes of trees2024-11-05 02:45treesmatrix2024-11-06 00:01-tree level order traversal2024-11-06 00:15binary trees and binary search treestim sort2024-11-06 00:12searching &amp; sortinglinear probing2024-11-05 23:58hash functionstopological sorting using khanâ€™s algo2024-11-05 03:03topological sortinggraphs depth first search2024-11-05 23:52graphsdirected acyclic graphs2024-11-05 23:30cyclic and acyclic graphstrees2024-11-06 00:16-queue2024-11-06 00:04-searching &amp; sorting2024-11-06 00:07-binary trees and binary search trees2024-11-05 23:46treestopological sorting2024-11-05 03:02directed acyclic graphshash functions2024-11-05 23:53hash tableslinked list2024-11-05 23:59-quick sort2024-11-06 00:05arraysgraph representations2024-11-05 03:04graphstree depth traversals2024-11-06 00:15binary trees and binary search trees\n"},"ğŸ¥·ğŸ½-jutsus/essential-python-built-ins":{"title":"essential python built-ins","links":["Arrays"],"tags":["zettel","interview-prep","dsa"],"content":"essential python built-ins\n\nenumerate: getting values and index at the same time in a for loop.\n\nfor i, value in enumerate(nums):\n\nzip: iterate on 2 Arrays at the same time.\nset: to store only unique values, i.e no duplicates allowed.\ndeque: A double ended queue.\n\ndq = collections.deque()\ndq = deque()\n \ndq.append(val) # push right\ndq.pop() # pop right\ndq.appendleft() # push left\ndq.popleft() # pop left\n\ncounter: returns the freq of elements of a iterable variable.\n\nfreq = collections.Counter(var) # var -&gt; list, string or any iterable\nfor f in freq.keys():\n\tprint(f, &quot;: &quot;, freq[f]) # &#039;a&#039;: 3 ...\nkeys = list(freq.keys()) # list of keys\nvalues = list(freq.values()) # list of values\nfor f in freq.elements():\n\tprint(f, &quot; &quot;) # g g e e e ...\n \n# Add 2 counter variables\nfrom collections import Counter  \n  \ncounter1 = Counter(a=3, b=2)  \ncounter2 = Counter(a=1, b=2, c=3)  \ncombined = counter1 + counter2 # Output: Counter({&#039;a&#039;: 4, &#039;b&#039;: 4, &#039;c&#039;: 3})\n \n# Subtract 2 counter variables\ndifference = counter1 - counter2 # Output: Counter({&#039;a&#039;: 2}) | Considers the first counter as primary therefore as &#039;c&#039; was not present in first counter it was not considered (if you subtract it becomes -ve)\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/feat---create-groups-and-permissions-for-users":{"title":"feat - create groups and permissions for users","links":["ğŸ¥·ğŸ½-jutsus/SyncWise","ğŸ¥·ğŸ½-jutsus/GradeSync","ğŸ¥·ğŸ½-jutsus/gradesync-db-design-updated"],"tags":["pr"],"content":"PROJECT: SyncWise\nLINK: GRADESYNC: started new app gradesync and added DB models. by Srikar-V675 Â· Pull Request #6 Â· Srikar-V675/syncwise Â· GitHub\nBRANCH: fastapi-to-drf\nChanges\n\nCreated the db models that is needed for GradeSync.\nExtended the default users table to have department foreign key.\nCreated groups: HODs, Teachers, Students and gave appropriate permissions\nCustomised the admin page to reflect the permissions set above for CRUD operations by different groups.\n\nDescription\nDB models\nRefer here for the updated db-design: gradesync db-design updated\nDepartment FK in users\nIn the above Schema you can see that the departments is extended as a foriegn key to the users table. Iâ€™ve decided to go with this because Iâ€™m pretty sure our users would either be teachers or students. They belong to one department and they must be able to access the data related to their department only.\nGroups and Permissions\nSince our users are either teachers or students, we need to make sure they have the right permissions to perform the actions they are allowed to do. For example: teachers can perform CRUD ops on students while the students can only read.\nI looked into two options:\n\none was to create another table called Roles.\nsecond was to use the groups and permissions feature given by django as default.\n\nCreating another table Roles would create an extra overhead for us to keep checking the roles for every endpoint or feature we try to implement.\nIn the case of groups and permissions, we would need effort in setting up in the first. But after that we can just use the default permissions or custom permissions when we want to make sure the right group accesses it.\nHODs: this group is for performing CRUD ops on both Teachers and Students. As there needs to be someone to manage Teachers too.\nTeachers: this group is performing CRUD ops on Students alone. You can guess why.\nStudents: they essentially donâ€™t have any permissions except read.\nCustom Admin Page\ngraph TD;\n\tUsers --&gt; Superusers(admins)\n\tUsers --&gt; HODs\n\tUsers --&gt; Teachers\n\tUsers --&gt; Students\n\tHODs --&gt; CRUD-Users-Teachers\n\tHODs --&gt; CRUD-Users-Students\n\tTeachers --&gt; CRUD-Users-Students\n\tStudents --&gt; Read-only\n\nIâ€™ve created custom admin pages for the groups: HODs and Teachers, as these groups are the ones that perform CRUD ops on the users.\nIâ€™ve created an admin model form from the users model to manipulate the form options based on the group the user belongs to.\nHODs have the power to create, update, read and delete both teachers and students. HODs are responsible for managing the teachers.\nTeachers have the power to create, update, read and delete students. They are responsible for managing the students.\n\nNOTE: both groups can only perform ops on the users that belong to their department.\n\n\nRefer to the setup.md file to make the migrations and create the default groups.\n\nNext tasks\n\n create unit test for testing the above changes\n allow bulk student user creation(from excel files)\n admin page for teachers must have filtering options based on student profile\n for HODs and superusers the Users must be segregrated by groups with distinction.\n"},"ğŸ¥·ğŸ½-jutsus/gradesync-architecture":{"title":"gradesync architecture","links":["ğŸ¥·ğŸ½-jutsus/SyncWise"],"tags":["documentation"],"content":"gradesync architecture\nPROJECT: SyncWise\nArchitecture\n---\ntitle: GradeSync Current Architecture\n---\nflowchart TD\n\tBrowser -- request ---&gt; Auth-Middleware\n\tAuth-Middleware -- authenticated ---&gt; API-Service\n\tAuth-Middleware -- unauthorised ---&gt; Browser\n\tAPI-Service -- write ---&gt; db[(database)]\n\tdb[(database)] -- read --&gt; API-Service\n\tAPI-Service -- response ---&gt; Browser\n"},"ğŸ¥·ğŸ½-jutsus/gradesync-db-design-updated":{"title":"gradesync db-design updated","links":["ğŸ¥·ğŸ½-jutsus/SyncWise"],"tags":["documentation"],"content":"gradesync db-design updates\nPROJECT: SyncWise\nSchema\nerDiagram\n\tGROUPS {\n\t\tint id PK\n\t\tstring group_name\n\t\tstring permissions\n\t}\n\tUSERS {\n\t\tint id PK\n\t\tstring username\n\t\tstring password\n\t\tstring email\n\t\tint department FK\n\t\tint group FK\n\t}\n    DEPARTMENTS {\n        int id PK\n        string dept_name\n    }\n    BATCHES {\n        int id PK\n        int dept FK\n        string batch_name \n        int scheme\n        int num_students \n        int batch_start_year\n        int batch_end_year\n    }\n    SECTIONS {\n\t    int id PK\n        int batch FK\n        string section \n        int num_students\n    }\n    SEMESTERS {\n\t    int id PK\n\t    int batch FK\n\t    int sem_num \n\t    int num_subjects \n\t    bool current\n    }\n    STUDENTS {\n     int id PK\n     int user FK\n     int batch FK\n     int section FK\n     int semester FK\n     string usn\n     decimal cgpa\n     bool active\n     int num_backlogs\n    }\n    SUBJECTS {\n\t    int id PK\n\t    int semester FK\n\t    string sub_code\n\t    string sub_name\n\t    int credits\n    }\n    FACULTY {\n\t    NOT YET-IMPLEMENTED\n    }\n    MARKS {\n\t    int id PK\n\t    int student FK\n\t    int subject FK\n\t    int section FK\n\t    int internal\n\t    int external\n\t    int total\n\t    char result \n\t    string grade \n    }\n    STUDENT_PERFORMANCES {\n\t    int id PK\n\t    int student FK\n\t    int semester FK\n\t    int total \n\t    decimal percentage \n\t    decimal sgpa\n    }\n    USERS ||--|{ DEPARTMENTS : part-of\n    USERS ||--|{ STUDENTS : profile\n    USERS ||--|{ GROUPS : belong-to\n\tBATCHES ||--|{ SECTIONS : contains \n\tBATCHES ||--|{ SEMESTERS : has \n\tBATCHES ||--|{ STUDENTS : consist-of\n\tSECTIONS ||--|{ STUDENTS : consist-of\n\tDEPARTMENTS ||--|{ BATCHES : has\n\tSEMESTERS ||--|{ STUDENTS : current\n\tSEMESTERS ||--|{ SUBJECTS : have\n\tSTUDENTS ||--|{ MARKS : scored\n\tSUBJECTS ||--|{ MARKS : has \n\tSECTIONS ||--|{ MARKS : scored\n\tSTUDENTS ||--|{ STUDENT_PERFORMANCES : performance \n\tSEMESTERS ||--|{ STUDENT_PERFORMANCES : performance\n"},"ğŸ¥·ğŸ½-jutsus/gradesync-db-design":{"title":"gradesync db-design","links":["ğŸ¥·ğŸ½-jutsus/SyncWise"],"tags":["documentation"],"content":"gradesync db-design\nPROJECT: SyncWise\nDB Design\nerDiagram\n    DEPARTMENTS {\n        int dept_id PK, FK\n        string dept_name\n        string password\n    }\n    BATCHES {\n        int batch_id PK, FK\n        int dept_id FK\n        string batch_name \n        int scheme\n        int num_students \n        int batch_start_year\n        int batch_end_year \n        string start_usn \n        string end_usn \n        string lateral_start_usn \n        string lateral_end_usn \n    }\n    SECTIONS {\n\t    int section_id PK\n        int batch_id FK\n        string section \n        int num_students \n        string start_usn \n        string end_usn \n        string lateral_start_usn \n        string lateral_end_usn \n    }\n    SEMESTERS {\n\t    int sem_id PK\n\t    int batch_id FK\n\t    int sem_num \n\t    int num_subjects \n\t    bool current\n    }\n    STUDENTS {\n     int stud_id PK\n     int batch_id FK\n     int section_id FK\n     int current_sem FK\n     string usn \n     string stud_name \n     decimal cgpa\n     bool active\n    }\n    SUBJECTS {\n\t    int subject_id PK\n\t    int sem_id FK\n\t    string sub_code \n\t    string sub_name\n\t    int credits\n    }\n    MARKS {\n\t    int mark_id PK\n\t    int stud_id FK\n\t    int subject_id FK\n\t    int section_id FK\n\t    int internal\n\t    int external\n\t    int total\n\t    char result \n\t    string grade \n    }\n    STUDENT_PERFORMANCES {\n\t    int stud_perf_id PK\n\t    int stud_id FK\n\t    int sem_id FK\n\t    int total \n\t    decimal percentage \n\t    decimal sgpa\n    }\n\tBATCHES ||--|{ SECTIONS : contains \n\tBATCHES ||--|{ SEMESTERS : has \n\tBATCHES ||--|{ STUDENTS : consist-of\n\tSECTIONS ||--|{ STUDENTS : consist-of\n\tDEPARTMENTS ||--|{ BATCHES : has\n\tSEMESTERS ||--|{ STUDENTS : current\n\tSEMESTERS ||--|{ SUBJECTS : have\n\tSTUDENTS ||--|{ MARKS : scored\n\tSUBJECTS ||--|{ MARKS : has \n\tSECTIONS ||--|{ MARKS : scored\n\tSTUDENTS ||--|{ STUDENT_PERFORMANCES : performance \n\tSEMESTERS ||--|{ STUDENT_PERFORMANCES : performance\n"},"ğŸ¥·ğŸ½-jutsus/graph-representations":{"title":"graph representations","links":["ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/trees","Arrays","Matrix","Linked-List","ğŸ¥·ğŸ½-jutsus/hash-tables","ğŸ¥·ğŸ½-jutsus/adjacency-list-problems"],"tags":["zettel","dsa"],"content":"graph representations\nGraph Representations\nSummary\ngraphs are unstructured data structures and have more freedom than trees hence there are several ways to represent graphs and each one of them have their pros and cons.\n---\ntitle: Undirected graph example\n---\ngraph LR;\n\t1 --- 2\n\t2 --- 3\n\t3 --- 1\n\nEdge List\nRepresents graphs as a list(or array) of mapping between vertices which is also an individual Arrays of vertices pairs.\nedge-list = [\n\t[1, 2],\n\t[2, 3],\n\t[3, 1]\n]\n\n\n\n                  \n                  Tip\n                  \n                \n\nThe pairs are unordered for undirected graphs and ordered for directed graphs.\n\n\nAdjacency Matrix\nRepresents graphs as a 2D Matrix with either 0, 1 or a number. The rows and columns represents the vertices and the corresponding value at [row, col] gives us the edge.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nValue at [i, j]01numMeaningno edge between node i and node jedge between node i and node jweight of edge between node i and node j\n  1  2  3\n  --------\n1|0  1  1\n2|1  0  1\n3|1  1  0\n\n\n\n                  \n                  Important\n                  \n                \n\nUndirected graphs adjacency matrix are symmetric along the diagonal and directed graphs adjacency matrix are un-symmetric along the diagonal.\n\n\nAdjacency List\nRepresents graphs as a list of vertices where each vertex points to a Linked List that contains pointers to the vertices that have edges from this vertex.\n[\n\t1 --&gt; 2 --&gt; 3 --&gt; NULL\n\t2 --&gt; 3 --&gt; 1 --&gt; NULL\n\t3 --&gt; 1 --&gt; 2 --&gt; NULL\n]\n\nHash table of hash tables\nRepresents graphs as literally what the name means where the outer hash table contains the vertices and each vertex has its own hash tables that contains the vertices it has a edge to.\n{\n\t1: {2, 3},\n\t2: {1, 3},\n\t3: {1, 2}\n}\n\n2D Grid or Matrix\nThis is a special type of representation for graphs, it is similar to adjacency matrix but is functionally different in the way it represents the graphs.\nThis representation is commonly used to represent spatial problems like mazes, finding islands etc.\nPoints to remember:\n\nEach cell is a node, unlike how in adjacency matrix each cell is an edge.\nAnd each nodes are neighbours are literally the nodes that are adjacent to it in the matrix.\nIn many cases 0 represents a boundary that means that if the neighbour of a node is 0 then that means that the current node canâ€™t visit that node.\n\n1 1 1 0\n0 1 1 0\n0 0 0 0\n0 1 1 0\n\n\n\n                  \n                  Example\n                  \n                \n\nLetâ€™s take an example of islands. To represent this we can use 1s for an island and 0s for sea or water. Itâ€™s clear that you canâ€™t go from sea to island and island to sea. And each cell in this grid represents either sea or island. You can also take an example of a maze where each node is either a path or a wall.\n\n\n\nComplexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRepresentationTime ComplexitySpace ComplexityProblemsEdge ListO(E)O(E)Access or search for an edge takes linear time and defeats the purpose even though we have O(E) extra space.Adjacency MatrixO(1)O(V^2)Access, insert, delete and search of an edge is constant time which is good but we always need an extra space of O(V^2) regardless of the number of edges. Hence if we have a sparse graph then space is waste.Adjacency ListO(d)O(E)(OR)O(2E)Refer to: adjacency list problemsHash table of hash tablesO(1)O(E)(OR)O(2E)It is a pretty solid representation for graphs.2D GridO(1)O(Row \\ . \\ Col)This kind of representation is good for spatial problems where the edges are adjacent to nodes(up, down, left, right, maybe diagonal too). And they can be space in-efficient for sparse graphs.\n\nRelated Notes\ngraphs\nadjacency list problems\nReferences(links)\nFrom Theory To Practice: Representing Graphs | by Vaidehi Joshi | basecs | Medium\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/graphs-breadth-first-search":{"title":"graphs breadth first search","links":["ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal","Queue","ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/graph-representations","Matrix"],"tags":["zettel","dsa"],"content":"Breadth First Search\nSummary\nSimilar to how we implement tree level order traversal which is nothing but breadth first search, where we visit each node in a level and only then move on to the next level.\nThe basic steps of breadth first search in graphs are:\n\nAdd the first node to the Queue and mark it as visited.\nDetermine the neighbours of the topmost node in the Queue.\nVisit the neighbours if not in visited and add them to the Queue and mark them as visited.\nPop the topmost node in the Queue.\n\nWe are visiting the nodes and adding them to the Queue and marking them visited.\nQ: Why are you adding to the Queue if you have visited it already?\nA: because I want to make sure I visit the neighbours of the node that I just visited.\n\n\n\n                  \n                  Note\n                  \n                \n\nIf a node is visited then the traversal doesnâ€™t visit it again it instead ignores it.\n\n\nIf we map the path the traversal took as a tree ignoring the lookups of visited edges. Then we get this:\ngraph TD;\n\tb --&gt; a\n\tb --&gt; f\n\ta --&gt; e\n\tf --&gt; c\n\tf --&gt; g\n\tc --&gt; d\n\tg --&gt; h\n\n\n\n                  \n                  Important\n                  \n                \n\nThe power of using BFS to traverse through a graphs is that it can easily and will always tell us the shortest way of getting from one node to another. You can validate it in the above trees that the traversal mapped.\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nWe will need an extra data structure to check the vertex is visited or not.\n\n\nTime Complexity\nO(V + E)\nO(Row \\ . \\ Col)\nWhy?\nA: If we think of how we traverse for a single node. What we do is for each node we visit, we lookup its neighbouring nodes regardless of the fact that it was visited or is in the queue. Hence we we would be looking up each edge and also visiting each vertex hence the time complexity is the sum of them.\n\n\n                  \n                  Hint\n                  \n                \n\nO(V + E) is valid for any graph representations that have the exact edges. But in the case of 2D Grid or Matrix for which the complexity is O(Row . Col) in the worst case.\n\n\n\n\n                  \n                  Important\n                  \n                \n\nFor an undirected graph, we would be visiting all vertices V and 2E edges. For a directed graphs, we would be visiting all vertices V and E edges.\n\n\nCode\nMatrix\nnum_rows, num_cols = len(matrx), len(matrix[0])\ndef get_neighbours(coord):\n\trow, col = coord\n\tdirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\tneighbours = []\n\tfor direction in directions:\n\t\tnext_row = row + direction[0]\n\t\tnext_col = col + direction[1]\n\t\tif 0 &lt;= next_row &lt; num_rows and 0 &lt;= next_col &lt; num_cols:\n\t\t\tneighbours.append((next_row, next_col))\n\treturn neighbours\n \ndef bfs(starting_node):\n\tq = deque([starting_node])\n\tvisited = set([starting_node])\n\twhile q:\n\t\tnode = q.popleft()\n\t\tfor neighbour in get_neighbours(node):\n\t\t\tif neighbour in visited:\n\t\t\t\tcontinue \n\t\t\t# Do stuff with the node if required\n\t\t\t# ...\n\t\t\tq.append(neighbour)\n\t\t\tvisited.add(neighbour)\nOther Representations\nThe bfs function remains the same. get_neighbours() is the function that changes cause that is where we determine the neighbours.\n\nRelated Notes\ngraphs\ngraph representations\ntree level order traversal\nReferences(links)\nGoing Broad In A Graph: BFS Traversal | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/graphs-depth-first-search":{"title":"graphs depth first search","links":["ğŸ¥·ğŸ½-jutsus/tree-depth-traversals","Recursion","ğŸ¥·ğŸ½-jutsus/graphs","Stack","ğŸ¥·ğŸ½-jutsus/graphs-breadth-first-search","Matrix","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/graph-representations"],"tags":["zettel","dsa"],"content":"Graph DFS\nCaptures\nJust like tree depth traversals, graph DFS also works very similarly and is again a Recursion problem since at every single step we make the same operation and if we reach the base case (which is all neighbouring nodes are visited) then we backtrack and try to find an other route.\nDFS sticks to one path and follows the structure until it ends and then backtrack to find another path.\n\n\n                  \n                  Tldr\n                  \n                \n\nDFS algorithm is more like a solving a maze, where we pick one path and if we reach a dead end then we back track and check another path. This repeats until we have found the exit or we have run out of paths.\n\n\n\nBase case of a DFS graphs Recursion is when every single neighbour of a node is visited or there are no outgoing edges.\nBasic steps of DFS in graphs are:\n\nadd the node to the top of the Stack.\nMark it as visited and check its neighbouring nodes.\nAdd one of the non-visited neighbouring nodes to the stack and repeat from step-2. If there are no non-visited neighbouring nodes pop it out of the Stack.\n\nTime Complexity\nVery similar to graphs breadth first search complexity. Since ultimately we are visiting all the vertices and all its edges at-least once.\nTransclude of graphs-breadth-first-search#time-complexity\n\n\n                  \n                  Important\n                  \n                \n\nThe power of DFS on a graph is that it helps us check if a path exists between node x and node y. But it doesnâ€™t guarantee us the shortest path (could also give us the longest path) but it just tells us if a path exists.\n\n\nCode\nMatrix\nnum_rows, num_cols = len(matrix), len(matrix[0])\ndef get_neighbours(coord): \n\trow, col = coord \n\tdirections = [(0, 1), (0, -1), (1, 0), (-1, 0)] \n\tneighbours = [] \n\tfor direction in directions: \n\t\tnext_row = row + direction[0] \n\t\tnext_col = col + direction[1] \n\t\tif 0 &lt;= next_row &lt; num_rows and 0 &lt;= next_col &lt; num_cols:\n\t\t\tneighbours.append((next_row, next_col)) \n\treturn neighbours\n \ndef dfs(node, visited):\n\tif node in visited: \n\t\treturn \n\tvisited.add(node)\n\tfor neighbour in get_neighbours(node):\n\t\tdfs(neighbour, visited)\n \nvisited = set()\ndfs(starting_node, visited)\nTransclude of graphs-breadth-first-search#other-representations\nIterative\nstack = deque([starting_node])\nvisited = set([starting_node])\n \nwhile stack:\n\tnode = stack.pop()\n\tfor neighbour in get_neighbours(node):\n\t\tif neighbour in visited:\n\t\t\tcontinue\n\t\tvisited.add(neighbour)\n\t\tstack.append(neighbour)\n\nRelated Notes\ngraphs\ngraphs breadth first search\nStack\ntree depth traversals\ntrees\ngraph representations\nRecursion\nReferences(links)\nDeep Dive Through A Graph: DFS Traversal | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/graphs":{"title":"graphs","links":["ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/graph-representations","ğŸ¥·ğŸ½-jutsus/graphs-breadth-first-search","ğŸ¥·ğŸ½-jutsus/graphs-depth-first-search","ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs","ğŸ¥·ğŸ½-jutsus/topological-sorting","ğŸ¥·ğŸ½-jutsus/topological-sorting-using-dfs","ğŸ¥·ğŸ½-jutsus/topological-sorting-using-khan's-algo","ğŸ¥·ğŸ½-jutsus/types-of-graph-edges"],"tags":["zettel","dsa"],"content":"Graphs\nSummary\nGraphs is an abstract data structure derived from mathematics, it is a set of objects (nodes or vertices) where there can be edges that connect these nodes or vertices.\nMathematical definition of a graph:\nG = (V, \\ E)\nEdges can be directed, undirected and can also have weights. trees are undirected and acyclic graphs. trees can be considered as a subset of graphs.\n\n\n                  \n                  Quote\n                  \n                \n\nâ€œA tree will always be a graph, but not all graphs will be trees.â€\n\n\n\n\n                  \n                  Info\n                  \n                \n\ntrees have a set of rules that need to be followed to make them a tree, while graphs donâ€™t have any of these rules, the one and only rule is there are nodes and there are edges that connect these nodes. graphs are like the pirates and trees are like the marines from the one piece world.\n\n\nGraphs are used to represent relationships between objects (nodes or vertices) like social media following, distance between locations etc\n---\ntitle: Facebook Friends Graph \n---\ngraph LR;\n\tSrikar --- Vignesh\n\tSrikar --- Shasha\n\tSrikar --- Murthy\n\tMurthy --- Shasha\n\tVignesh --- Trupthi\n\tShasha --- Trupthi\n\n---\ntitle: Twitter Following Graph \n---\ngraph LR;\n\tSrikar --&gt; Weeknd\n\tSrikar --&gt; Neetcode\n\tSrikar --&gt; Vignesh \n\tVignesh --&gt; Srikar\n\nTasks\n\n Topological sorting âœ… 2024-10-13\n Dijkstraâ€™s\n Types of graphs\n DFS, BFS, Topological sorting, dijikstraâ€™s code. âœ… 2024-10-13\n\n\nRelated Notes\ngraph representations\ngraphs breadth first search\ntrees\ngraphs depth first search\ndirected acyclic graphs\ntopological sorting\ntopological sorting using dfs\ntopological sorting using khanâ€™s algo\ntypes of graph edges\nReferences(links)\nA Gentle Introduction To Graph Theory | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/hash-functions":{"title":"hash functions","links":["ğŸ¥·ğŸ½-jutsus/hash-tables","Arrays"],"tags":["zettel","dsa"],"content":"Hash Functions\nSummary\nHash functions are an integral part of hash tables. These functions let us map a key to a value, it performs some kind of operation on the key to determine the index in which the value should be stored in hash tables.\nThe value can be an index to an array that contains the actual value or the value itself.\n\n\n                  \n                  Example\n                  \n                \n\nIf The Book of Life is the key then the value could be the row in the shelf in which the book is in the library. Here the shelf can be the array and the row is the index of the array.\n\n\n\nEach index of the hash tables are called buckets and can sometimes hold more than one value, this scenario is called a collision.\n\n\n                  \n                  Example\n                  \n                \n\nAn example of a collision would be if there was another book with 13 letters in the above example then even that book would belong to the bucket-1 in hash table.\n\n\nThe concept of collisions is still a better idea than searching the entire array because we are decreasing the search space drastically, but collisions can cause a problem if majority of elements are mapped to a single bucket. Hence a good hash function is one that can distribute the keys equally among the buckets and is easy to compute.\n\nKey Terms\nBuckets: refers to each index of hash tables that stores a value.\nCollisions: can happen when two keys belong to the same bucket in hash tables.\nRelated Notes\nArrays\nhash tables\nReferences(links)\nHashing Out Hash Functions. Over the course of the past few monthsâ€¦ | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/hash-tables":{"title":"hash tables","links":["Arrays","ğŸ¥·ğŸ½-jutsus/hash-functions","ğŸ¥·ğŸ½-jutsus/linear-probing","ğŸ¥·ğŸ½-jutsus/chaining","Strings","Linked-List"],"tags":["zettel","dsa"],"content":"Hash Tables\nSummary\nIt is a data structure that maps keys to values and enabling O(1) lookup by the key. It allows us to search for an item in an array in O(1) time which usually takes O(N) time for unsorted array and O(log N) time for a sorted array.\nDetailed Explanation\nScenario:\nLetâ€™s say we have a library of books and I want to search for a book, a traditional way would essentially be searching through all the books in library or if the books are sorted then we look in the right half and narrow it down. But isnâ€™t this super inconvenient, imagine having 1000 books and using these traditional ways to search for a book. The need for a data structure that allows us to access or search a book directly is needed â†’ O(1) access.\nSolution:\nA hashmap data structure that can help us do this.\nA hashmap has two main parts:\n\nArrays - used to store the data aka books\nHash Function - used to create a mapping that decides where our data is\n\nWhat makes a good hash table?\n\nEasy to compute hash function\nAvoid collisions\nShould use all input data and must return the same value for a given input\n\nCollision Resolution Tactics\nWe know we canâ€™t avoid collisions but we can efficiently handle them. We have 2 main types:\nOpen Addressing - When an element has to be inserted, it examines the bucket for the input values, if that bucket is occupied then it uses some kind of probe sequence to find the next unoccupied slot in the table.\n\nlinear probing\n\nClosed Addressing - Implements a new data structure where if there is a collision then that data structure is extended at that bucket (i.e Linked List).\n\nchaining\n\nTime Complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-ONoteAccessN/AAccessing not possible as the hash code is not knownSearchO(1)*InsertO(1)*RemoveO(1)**Â This is the average case, but in interviews we only care about the average case for hash tables.\nSample questions\n\nDescribe an implementation of a least-used cache, and big-O notation of it.\nA question involving an APIâ€™s integration with hash map where the buckets of hash map are made up of linked lists.\nEssential Qs\n2Sum\nRansom Note\n\nTasks\n\n Research the Sample Questions more\n\nKey Terms\nHash function: The algorithm that decides the hash bucket of a input value\nHash bucket: The index of a hash table that holds the value of a key\nCollision: When two input values given to a hash function result in the same hash bucket\nRelated Notes\nArrays\nStrings\nhash functions\nlinear probing\nchaining\nLinked List\nReferences(links)\nHash table cheatsheet for coding interviews | Tech Interview Handbook\nTaking Hash Tables Off The Shelf. Truth time: learning about theoreticalâ€¦ | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/how-uber-computes-ETA":{"title":"how uber computes ETA","links":["ğŸ¥·ğŸ½-jutsus/graphs"],"tags":["zettel","system-design"],"content":"Uber ETA Computation\nUber uses a graphs representation of the map or the route, where the roads are the edges and the intersections are nodes.\nThey partition the graphs and pre-compute the time to efficiently estimate the ETA. This partition makes it easy to compute without using the dijikstrasâ€™s algo which can be expensive for a graph that can contain 100s of thousands of nodes (intersections).\nThe graphs are weighted graphs that denote the traffic and distance based on the traffic, which further optimises the efficiency of ETA.\nRead and dive deep further into the topic. refer to the references below.\n\nRelated Notes\nReferences(links)\nğŸ’ª Try this Microsoft problem\nUber ETA - by Neo Kim - System Design Newsletter\nUber Blogs - H3"},"ğŸ¥·ğŸ½-jutsus/important-patterns-and-strategies":{"title":"important patterns and strategies","links":["ğŸ¥·ğŸ½-jutsus/dsa","Two-Pointers","Sliding-Window","Stack","Binary-Search"],"tags":["zettel","interview-prep","dsa"],"content":"important patterns and strategies\nDSA Patterns\n\n Prefix Sum\n Two-Pointers\n Sliding-Window\n Slow &amp; Fast Pointers -\n Monotonic Stack\n Top K Elements - Heaps &amp; Priority Queues\n Overlapping Interval - Scheduling algos &amp; Resource Allocation\n Binary Search\n BFS\n DFS\n Backtracking\n Dynamic Programming\n Topological Sorting\n Contribution Technique\n\n\nRelated Notes\nReferences(links)\n14 DSA Patterns which made my Coding Interviews Easy &amp; Landed Me a High-Paying Job || In Telugu"},"ğŸ¥·ğŸ½-jutsus/index":{"title":"index","links":[],"tags":[],"content":""},"ğŸ¥·ğŸ½-jutsus/intervals":{"title":"intervals","links":["Arrays","merge-intervals"],"tags":["zettel","dsa"],"content":"Intervals\nIntervals are just an extension of Arrays problems, where we have an array that contains intervals in the format [start, end].\nSo the input will look like this:\ninput = [[1,2],[2,3],[4,5], ...]\nWe will be performing operations on these intervals where first index is start and second index is end.\n\n\n                  \n                  Tip\n                  \n                \n\nClarify with the interviewer whether [1, 2] and [2, 3] are considered overlapping or not.\nAlso clarify whether [a, b] interval follows a&lt;b always.\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nUse number lines to represent intervals when working these kind of problems.\n\n\nTechniques\n\nSorting the intervals by the starting index(or start of interval)\nCheck if overlapping intervals\nMerge overlapping intervals\n\nEssential Qs\n\nmerge intervals\n\n\nRelated Notes\nArrays\nReferences(links)\ninterval-cheatsheet-for-coding-interviews-tech-interview-handboo"},"ğŸ¥·ğŸ½-jutsus/interview-prep":{"title":"interview prep","links":["ğŸ¥·ğŸ½-jutsus/dsa-mastery","ğŸ¥·ğŸ½-jutsus/system-design-resources","ğŸ¥·ğŸ½-jutsus/essential-python-built-ins"],"tags":["atlas"],"content":"interview prep\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourcedsa mastery2024-11-05 01:50-system design resources2024-11-05 01:47-essential python built-ins2024-11-05 01:43-\n"},"ğŸ¥·ğŸ½-jutsus/interviews":{"title":"interviews","links":["Ellucian","DeltaX","Accenture-Reflections","ZopSmart","Cognizant"],"tags":["project"],"content":"interviews\n\nEllucian\nDeltaX\nStackPro\nAccenture - Accenture Reflections\nSOTI\nFlipkart GRID\nWalmart\nStable Money - Applied by myself.\nInterview Kickstart - Applied by myself\nWinger\nKodNest\nZopSmart\nMonotype\nAimleap\nRubrik - SDE\nTime Pilot - NLP Engineer (Rubrik Resume)\nPeopleBox - QA-Engineer (Rubrik Resume)\nSatsure - Satsure Resume (Note: Transformer Re implementation put in project)\nCognizant - Rubrik Resume\nRazorpay - Rubrik Resume\nZWC - ZWC Resume\n\nLinks &amp; References"},"ğŸ¥·ğŸ½-jutsus/joins-in-sql":{"title":"joins in sql","links":[],"tags":["zettel","databases"],"content":"Joins in SQL\nSummary\nJoins in SQL are a way of combining tables that are related by a primary &amp; foreign key relationship or by common rows. It helps maintain the data integrity, schema and minimise redundancy.\nTypes\nInner Join: result-set contains only the rows that have matching values in both left and right tables.\nLeft Join: result-set contains all the rows in left table and matching rows of right table. Unmatched rows will contain NULL.\nRight Join: result-set contains all the rows in right table and matching rows of left table. Unmatched rows will contain NULL.\nFull Join: result-set contains a combination of rows in left table and right table. Unmatched rows will contain NULL.\nNatural Join: combines two tables based on common columns in the two tables. The common columns are not specified but identified by SQL and the matching rows of the tables are combined.\nTasks\n\n Further exploration on Joins\n Explore syntax of joins and natural joins\n\n\nRelated Notes\nReferences(links)\nSQL Joins (Inner, Left, Right and Full Join)"},"ğŸ¥·ğŸ½-jutsus/learning-from-interview-rejections":{"title":"learning from interview rejections","links":["Interv","Job-Prep","04-Atlas/DSA"],"tags":["zettel","interview-prep"],"content":"Interview Rejections\nSummary\nDonâ€™t feel dejected about Interv, things go bad very often and often times they are not your mistake that was the reason. There can be several instances of why it went wrong but make sure you learn from your mistakes and rejections.\nCaptures\nReferrals may get you the interview but not the job offer, keep this in mind as long as you are applying for jobs.\nMake sure you are rested well before the Interv, cause interviews at big tech companies can be exhausting.\nSometime rejections can tell you the right field that you are suited to work for. Maybe you were not suited for mobile dev and thatâ€™s the reason you got rejected.\nTake your rejections in a positive way, they can be saviours in disguise. As the writer of this blog experienced.\n\nHe was rejected from a company and this companyâ€™s stocks dropped 75% in the next 6 months. Hard Luck? ig yeah cause he dodges a bullet that could have given him some troubles.\n\n\n\n                  \n                  Quote\n                  \n                \n\nâ€œSometimes the interviewer fails you for reasons beyond your control and you need to take that signal and be grateful that you didnâ€™t get hired at that companyâ€\n\n\n\nRelated Notes\nInterv\nJob Prep\nDSA\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/level-order-traversal-by-level-dry-run":{"title":"level order traversal by level dry run","links":["ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal","ğŸ¥·ğŸ½-jutsus/trees"],"tags":["zettel","dsa"],"content":"level order traversal by level dry run\ngraph TD\nA(1) --&gt; B(2)\nA --&gt; C(3)\nB --&gt; D(4)\nB --&gt; E(5)\nC --&gt; F(6)\nC --&gt; G(7)\n\nTransclude of tree-level-order-traversal#iterative-code-by-level\nIteration-0:\nq = [1]\nlevel = []\nres = []\n\nIteration-1:\nq = [2, 3]\nlevel = [1]\nres = [ [1], ]\n\nIteration-2:\nq = [4, 5, 6, 7]\nlevel = [2, 3]\nres = [ \n\t[1], \n\t[2, 3]\n]\n\nIteration-3:\nq = []\nlevel = [4, 5, 6, 7]\nres = [ \n\t[1], \n\t[2, 3], \n\t[4, 5, 6, 7]\n]\n\n\nRelated Notes\ntree level order traversal\ntrees\nReferences(links)\nNeetcode.io yt videos. check it out."},"ğŸ¥·ğŸ½-jutsus/level-order-traversal-dry-run":{"title":"level order traversal dry run","links":["ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal","ğŸ¥·ğŸ½-jutsus/trees"],"tags":["zettel","dsa"],"content":"Level Order Traversal Dry Run\ngraph TD\nA(1) --&gt; B(2)\nA --&gt; C(3)\nB --&gt; D(4)\nB --&gt; E(5)\n\nTransclude of tree-level-order-traversal#iterative-code\nIteration-0:\nq = [1]\nres = None\n\nIteration-1:\nq = [2, 3]\nres = 1\n\nIteration-2:\nq = [3, 4, 5]\nres = 1, 2\n\nIteration-3:\nq = [4, 5]\nres = 1, 2, 3\n\nIteration-4:\nq = [5]\nres = 1, 2, 3, 4\n\nIteration-5:\nq = []\nres = 1, 2, 3, 4, 5\n\nends because q is empty\n\n\nRelated Notes\ntree level order traversal\ntrees\nReferences(links)\nNeetcode.io yt videos. check it out."},"ğŸ¥·ğŸ½-jutsus/linear-probing":{"title":"linear probing","links":["ğŸ¥·ğŸ½-jutsus/hash-tables","ğŸ¥·ğŸ½-jutsus/hash-functions","Arrays","ğŸ¥·ğŸ½-jutsus/chaining"],"tags":["zettel","dsa"],"content":"Linear Probing\nSummary\nLinear probing is a collision resolution tactic used in hash tables. It is an open addressing tactic. If there is a collision then the algorithm searches for the next free bucket linearly.\nA collision occurs when the hash functions generates the same bucket for two keys. To tackle this we can use linear probing, when a collision occurs the algorithm searches for the next unoccupied bucket linearly.\n\nIf a unoccupied bucket is not found and we have reached the end then the probe cycles to the first slot to search for the unoccupied slot.\n\n\nProblems\nClustering: occurs when we have lots of keys that belong to the same hash bucket according to the hash functions. Because of this the slots after the actual bucket is filled with values.\nUse linear probing when we have a ==well-defined hash functions and a big hash table== to accommodate collisions.\nDo not use linear probing if you have many keys that belong to the same hash bucket.\n\nRelated Notes\nhash tables\nhash functions\nArrays\nchaining\nReferences(links)\nHash Table (Closed Addressing: Separate Chaining and Open Addressing: Linear Probing, Quadratic Probing, Double Hashing) - VisuAlgo"},"ğŸ¥·ğŸ½-jutsus/linked-list":{"title":"linked list","links":["Arrays","Two-Pointers"],"tags":["zettel","dsa"],"content":"Linked List\nSummary\n\nLike Arrays, Linked Lists is used to represent sequential data. But the way they store the data differs, where Arrays store their elements in a contagious memory while linked lists stores its elements that are scattered in memory by linking their addresses.\n\n\n\nThe elements in a Linked List are called as Nodes.\n\nMemory Management\n\nBiggest differentiator between Arrays and linked lists is the memory management.\nArrays\n\ntake up more memory or make use of the operations more because whenever we create an array we need to find a contiguous block of memory and sometimes it can take time to find it.\nAnd when we need to add a element to an array, then if there is space we need to insert the array and shift the following elements. If there is no space or memory left then the whole array must be copied and recreated with more memory.\nIt is a static data structure.\n\n\n\n\n\n                  \n                  Note\n                  \n                \n\nIn the case dynamically typed languages like Ruby, JS, Python, we donâ€™t have to worry too much about how much memory an array uses as it is taken care of and is abstracted away. But it doesnâ€™t mean that it isnâ€™t happening because abstraction is just hiding away the things.\n\n\n\nLinked lists\n\nSince the nodes can be anywhere in the memory and as long as we have the address then we can link the nodes together.\nIn the case of adding elements we can just insert the new node and update the links you donâ€™t have to push the following elements like in Arrays. It is like doing a plug &amp; play.\nIt is a dynamic data structure.\n\n\n\nParts of a Linked List\n\nA Linked list contains a set of nodes that are linked together sequentially.\nEach individual node contains:\n\ndata: the actual value or element\nlink: the link to next node (address)\n\n\nThe last node usually is linked to a null to indicate the end of list.\nWe need to make sure we donâ€™t lose the head or the first element of the list as there is no other way to access the linked list otherwise.\n\n\n\n\n                  \n                  Quote\n                  \n                \n\nâ€œA node only knows about what data it holds and who its neighbours is.â€\n\n\nTypes of LL\nThe parts of linked lists donâ€™t usually change but the way we structure can change leading to different types of linked lists for different use cases.\n\nSingly Linked List - SLL\n\nThese type of linked lists are the most simple type.\nEach Node contains a data part and link part, where the link part links to the next Node of the same type.\nYou can traverse through the linked list only in one way - start at the head and go until you reach a NULL.\n\n\nDoubly Linked List - DLL\n\nAs the name suggests it has two links for each node: prev &amp; next.\nThe prev part points to the previous node and next part points to the next node in the list.\nSince they have two link parts they can travel in both ways from left to right or right to left.\n\n\nCircular Linked List\n\nIt is a weird data structure where the tail node is not NULL indicating end of list but there is a tail node that points to the head of the list which makes it circular.\nTraversing by trying to find a NULL would make it a infinite loop, you need to know when to stop.\nYou can add an element to end of list easily because you can directly use the tail node to add to list and make that the new tail node and point it tot the head.\nYou can implement both SLL &amp; DLL as a circular LL.\n\n\n\n\nTo Use or Not Use\n\nLinked lists are good when you usually need to insert or remove from the beginning of the list. But can be hell when you need to find or insert a element that is at the end of Linked list.\n\n\n\n                  \n                  Quote\n                  \n                \n\nA linked lists is usually efficient when you want to add or remove some elements, but can be very slow to search and find a single element.\n\n\nPoints to Remember:\n\nLinked lists are dynamic, they can grow &amp; shrink easily.\nInserting &amp; deleting is fast &amp; convenient\nSearching is slow\nFinding elements, requires traversal of whole LL and slow since you canâ€™t use binary search.\n\nTime complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-ONoteAccessO(n)SearchO(n)InsertO(1)Assumes you have traversed to the insertion positionRemoveO(1)Assumes you have traversed to the node to be removed\nCommon Routines\n\nFinding the number of nodes in linked list\nFinding middle or detecting cycle in LL by using the slow &amp; fast pointer\nReversing a LL in-place.\nMerge 2 LLs together.\n\nCorner Cases\n\nEmpty LL\nsingle node\ntwo nodes\nLL has cycles\n\n\n\n                  \n                  Tip\n                  \n                \n\nClarify with interviewer prior to solving a Linked List Q, if there can be a cycle in the Linked list.\n\n\nPatterns/Techniques\n\nMake use of dummy nodes in front of the head to tackle edge cases like empty LL or single node.\n2 pointers: use slow &amp; fast pointers effectively to solve Qs like find kth node from last, find the middle node, detect cycle in LL.\nElegant modification operations: make modifications in-place (reversal), truncate a LL, swapping values of nodes(not links), combining 2 LLs\n\nEssential Qs\n\nReverse Linked List\nLinked List Cycle\n\n\nKey Terms\n\nNode: Atomic component of a Linked List that usually contains 2 parts: data &amp; link.\nTraversal: Visiting every single node or element of a data structure sequentially.\nFast &amp; Slow Pointers: A technique used in LL Qs where one pointer moves faster(fast or hare pointer) than the other(slow or tortoise pointer).\n\nRelated Notes\n\nArrays\nTwo-Pointers\n\nReferences(links)\n\nLinked list cheatsheet for coding interviews | Tech Interview Handbook\nWhatâ€™s a Linked List, Anyway? [Part 1] | by Vaidehi Joshi | basecs | Medium\nWhatâ€™s a Linked List, Anyway? [Part 2] | by Vaidehi Joshi | basecs | Medium\n"},"ğŸ¥·ğŸ½-jutsus/linux-things-to-do":{"title":"linux things to-do","links":[],"tags":["zettel","linux"],"content":"linux things to-do\nDiwali Break â€˜24\nRe-Organise 2nd Brain:\n\n Inbox + Projects + Areas + Atlas + zettels all in one single folder as root notes. use metadata type to handle them. âœ… 2024-11-05\n Put dsa-problems into zettelkasten. âœ… 2024-11-05\n start setting up nvim. use side-by-side of VS-Code.\n Install linux on your macbook and make it a home server. âœ… 2024-11-05\n Configure next cloud on mac. âœ… 2024-11-05\n install and setup jupyter notebook and lab.\n Checkout GitHub - coollabsio/coolify: An open-source &amp; self-hostable Heroku / Netlify / Vercel alternative. for self-hosting websites.\n\nNvim\n\nmake sure to use nvim for obsidian notes and developement.\nsources:\nnvim-telekasten/telekasten.nvim\nReddit - Dive into anything\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/machine-learning":{"title":"machine learning","links":["ğŸ¥·ğŸ½-jutsus/5.-core-ml","ğŸ¥·ğŸ½-jutsus/SyncWise","ğŸ¥·ğŸ½-jutsus/bookshelf","ğŸ¥·ğŸ½-jutsus/ml-advice-from-experts","ğŸ¥·ğŸ½-jutsus/6.-mlops","ğŸ¥·ğŸ½-jutsus/project-ideas","ğŸ¥·ğŸ½-jutsus/reserach-papers-to-implement","ğŸ¥·ğŸ½-jutsus/ai-roadmap"],"tags":["atlas"],"content":"machine learning\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSource5. core ml2024-11-05 01:57-SyncWise2024-11-05 02:23-bookshelf2024-11-05 02:06-ml advice from experts2024-11-05 03:04-6. mlops2024-11-05 01:58-project ideas2024-11-05 02:04-reserach papers to implement2024-11-05 02:10-ai roadmap2024-11-05 02:08-\n"},"ğŸ¥·ğŸ½-jutsus/make-conceptual-notes-not-sequential":{"title":"make conceptual notes not sequential","links":[],"tags":["zettel","note-taking"],"content":"Conceptual Notes\nCaptures\n00:40\nWe care more about the information rather than the actual notes.\n02:55\nDo not write ever single thing that the resource you are learning from says or has mentioned, instead concentrate on understanding the concepts and evaluating them in your head, and trying to understand them.\n03:12\nTaking conceptual notes involves listening or reading the resource attentively and constantly evaluating whether the information presented to you (on a platter. :)) is USE.\n\nUSE: Unimportant, Self Explanatory or Easy to Memorize\n\n06:30\nLean on old stuff as support and donâ€™t forget them since most of the information you are consuming is one or the other way connected. Link your notes.\n08:21\nEverything in this world is not categorised into disciplines or domains as we do it, but they all are connected in one or the other way and lean more into one of the â€œdomainsâ€.\n\nMake sure to not limit your thoughts and link things.\n\n12:02\nThe way your brain stores or remembers information is my taking concepts and linking them, then why do you need to take sequential notes and increase the stress.\nInstead link your notes as you are taking them, making sure you study less later and reorganise it again.\nTasks\n\n Compile it when you find time.\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/matrix":{"title":"matrix","links":["Arrays"],"tags":["zettel","dsa"],"content":"Matrix\nSummary\n\nA matrix is a 2D array. Problems related to matrix usually involve: DP or graph traversal. In this note we will discussing about problems that come under matrix operations and not DP or graph traversal.\n\nTechniques\nCreating an empty NxM matrix\nWe often need to create an empty matrix of the same size as the original matrix to store visited states or the DP table.\n\n\n                  \n                  Tip\n                  \n                \n\nempty_matrix = [[0 for _ in range(len(matrix[0])) ] for _ in range(len(matrix))]\n\n\nCopying the Matrix\nWe also need to copy the original matrix to make changes in it and experiment without changing the original matrix.\n\n\n                  \n                  Tip\n                  \n                \n\ncopied_matrix = [ row[:] for row in matrix ]\n\n\nTransposing Matrix\nThere are operations on matrices that benefit from transposing the matrix. For many grid-based games it can be modelled as a matrix. Often to check the winning condition of the current state of game, we need to do it both horizontally and vertically, instead of writing code for verifying both horizontally and vertically we can write the code for horizontally only and then transpose the matrix to reuse the horizontal verification code.\n\n\n                  \n                  Tip\n                  \n                \n\ntranspose = zip(*matrix)\n\n\nEssential Qs\n\nSet Matrix Zeroes\nSpiral Matrix\n\nTasks\n\n Create permanent zettel\n\n\nKey Terms\n\nTranspose: Converting rows to columns and columns to rows in a matrix.\n\nRelated Notes\n\nArrays\n\nReferences(links)\nMatrix cheatsheet for coding interviews | Tech Interview Handbook"},"ğŸ¥·ğŸ½-jutsus/merge-sort":{"title":"merge sort","links":["Quick-Sort","Quick-Sort-vs-Merge-Sort","Stack","Arrays"],"tags":["zettel","dsa"],"content":"Merge Sort\nSummary\nA Divide &amp; Conquer approach to sorting.\nSplit the array into 2 halves at every step until they are single elements\nMerge the split halves by sorting them.\nThe splitting takes O(log n) time while the merge takes O(n) time hence time complexity is O(n.log n)\nComplexity\nTime Complexity: O(n. log n)\nWorst, Avg, Best are the same.\nSpace Complexity: O(n) â†’ because of the auxiliary space used.\n\nCode\nfrom typing import List\n \ndef merge(arr: List[int], low: int, mid: int, high: int):\n\ttemp = []\n\ti = low\n\tj = mid + 1\n\twhile i &lt;= mid and j &lt;= high:\n\t\tif arr[i] &lt;= arr[j]:\n\t\t\ttemp.append(arr[i])\n\t\t\ti += 1\n\t\telse:\n\t\t\ttemp.append(arr[j])\n\t\t\tj += 1\n\twhile i &lt;= mid:\n\t\ttemp.append(arr[i])\n\t\ti += 1\n\twhile j &lt;= high:\n\t\ttemp.append(arr[j])\n\t\tj += 1\n\tfor i in range(low, high+1):\n\t\tarr[i] = temp[i - low]\n \n \ndef mergeSort(arr: List[int], low: int, high: int):\n\tif low &lt; high:\n\t\tmid = (low + high) // 2\n\t\tmergeSort(arr, low, mid)\n\t\tmergeSort(arr, mid+1, high)\n\t\tmerge(arr, low, mid, high)\n \n \narr: List[int] = [54, 29, 93, 17, 77, 31]\nprint(arr)\nmergeSort(arr, 0, len(arr) - 1)\nprint(arr)\n\nQuestions\nWhy is merge sort not better than quick sort when merge sort has better time complexity in average? Answer: Quick Sort vs Merge Sort\nKey Terms\nAuxiliary Space: extra Stack space used when recursion takes place.\nRelated Notes\nArrays\nQuick Sort"},"ğŸ¥·ğŸ½-jutsus/mermaid-diagrams-docs":{"title":"mermaid diagrams docs","links":["ğŸ¥·ğŸ½-jutsus/mermaid-diagrams-docs"],"tags":["zettel","tools"],"content":"Mermaid Diagrams\nSummary\nMermaid is a tool that letâ€™s you create diagrams and visualisations using text and code. It is pretty easy if we are used to markdown and I feel is a very helpful tool in my obsidian note-taking workflow.\nGraph / Flowchart\nExample\ngraph TD;\n\tA --&gt; B\n\tA --&gt; C\n\tC --&gt; C\n\ngraph TB;\n\tA --&gt; B\n\tA --&gt; C\n\tC --&gt; C\n\nNode Shape\nround edges:\nflowchart LR\n    id1(This is the text in the box)\n\nflowchart LR\n    id1(This is the text in the box)\n\novalish:\nflowchart LR\n    id1([This is the text in the box])\n\nflowchart LR\n    id1([This is the text in the box])\n\ndatabase:\nflowchart LR\n    id1[(Database)]\n\nflowchart LR\n    id1[(Database)]\n\ncircle:\nflowchart LR\n    id1((This is the text in the circle))\n\nflowchart LR\n    id1((This is the text in the circle))\n\nLinks b/w Nodes\narrow link:\nflowchart LR\n    A--&gt;B\n\nflowchart LR\n    A --&gt; B\n\nno arrow link:\n    A---B\nflowchart LR\n    A---B\n\ntext on link:\nflowchart LR\n    A-- text --&gt;B\n\nflowchart LR\n    A-- text --&gt;B\n\ndotted link:\nflowchart LR\n   A-.-&gt;B;\n\nflowchart LR\n   A-.-&gt;B;\n\ndotted link with text:\nflowchart LR\n   A-. text .-&gt; B\n\nflowchart LR\n   A-. text .-&gt; B\n\nthick link:\nflowchart LR\n   A ==&gt; B\n\nflowchart LR\n   A ==&gt; B\n\nArrow Types\ncircle edge:\nflowchart LR\n    A --o B\n\nflowchart LR\n    A --o B\n\ncross-edge:\nflowchart LR\n    A --x B\n\nflowchart LR\n    A --x B\n\nSubgraphs\nflowchart TB\n    c1--&gt;a2\n    subgraph one\n    a1--&gt;a2\n    end\n    subgraph two\n    b1--&gt;b2\n    end\n    subgraph three\n    c1--&gt;c2\n    end\n    one --&gt; two\n    three --&gt; two\n    two --&gt; c2\n\nflowchart TB\n    c1--&gt;a2\n    subgraph one\n    a1--&gt;a2\n    end\n    subgraph two\n    b1--&gt;b2\n    end\n    subgraph three\n    c1--&gt;c2\n    end\n    one --&gt; two\n    three --&gt; two\n    two --&gt; c2\n\nER-Diagrams\nExample\n---\ntitle: Order example\n---\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\n---\ntitle: Order example\n---\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    CUSTOMER {\n        string name\n        string custNumber\n        string sector\n    }\n    ORDER ||--|{ LINE-ITEM : contains\n    ORDER {\n        int orderNumber\n        string deliveryAddress\n    }\n    LINE-ITEM {\n        string productCode\n        int quantity\n        float pricePerUnit\n    }\n\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    CUSTOMER {\n        string name\n        string custNumber\n        string sector\n    }\n    ORDER ||--|{ LINE-ITEM : contains\n    ORDER {\n        int orderNumber\n        string deliveryAddress\n    }\n    LINE-ITEM {\n        string productCode\n        int quantity\n        float pricePerUnit\n    }\n\nMindmap\nExample\n  root((mindmap))\n    Origins\n      Long history\n      Popularisation\n        British popular psychology author Tony Buzan\n    Research\n      On effectiveness&lt;br/&gt;and features\n      On Automatic creation\n        Uses\n            Creative techniques\n            Strategic planning\n            Argument mapping\n    Tools\n      Pen and paper\n      Mermaid\n\nmindmap\n  root((mindmap))\n    Origins\n      Long history\n      Popularisation\n        British popular psychology author Tony Buzan\n    Research\n      On effectiveness&lt;br/&gt;and features\n      On Automatic creation\n        Uses\n            Creative techniques\n            Strategic planning\n            Argument mapping\n    Tools\n      Pen and paper\n      Mermaid\n\nshapes\nrefer: Node Shape\nbang:\nmindmap\n    root))I am a bang((\n\t\tA\n\nmindmap\n    root))I am a bang((\n\t    A\n\ncloud:\nmindmap\n    root)I am a cloud(\n\t\tA\n\nmindmap\n    root)I am a cloud(\n\t    A\n\nTasks\n\n Further explore ER diagrams. refer: Entity Relationship Diagrams | Mermaid\n Architecture diagrams. refer: Architecture Diagrams Documentation (v11.1.0+) | Mermaid\n state diagrams. refer: State diagrams | Mermaid\n\n\nRelated Notes\nReferences(links)\nAbout Mermaid | Mermaid"},"ğŸ¥·ğŸ½-jutsus/ml-advice-from-experts":{"title":"ml advice from experts","links":[],"tags":["zettel","machine-learning","ai"],"content":"ML Advice\n00:28\nPeople that can debug ml algorithms very good are easily 10x or 100x faster at getting something to work.\n01:07\nYou canâ€™t learn programming by watching a tutorial, you can learn it when you build something that was genuinely a problem you faced.\n01:58\nDonâ€™t be afraid to get your hands dirty. If there is some problem or error try to figure it out by yourself, do not google or look into resources. Spend that 5, 10 or 15 hours and youâ€™ll learn a lot.\n02:19\nCultivate a habit of reading research papers, not just 1 or 2 but 1 or 2 every week. After a few month or years youâ€™ve read enough to have learnt a lot.\n04:07\nWhen you have a choice to create something, always go for creation. Youâ€™ll learn loads from it.\n05:55\nKnow yourself. Figure out how you work, what are the times that you study well? Test yourself in various scenarios and try to improve on your shortcomings. Just like how you lately realised that you talk first and think/regret later.\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/note-taking":{"title":"note-taking","links":["ğŸ¥·ğŸ½-jutsus/make-conceptual-notes-not-sequential","ğŸ¥·ğŸ½-jutsus/plan-your-learning-in-10-mins"],"tags":["atlas"],"content":"note-taking\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourcemake conceptual notes not sequential2024-11-06 00:00-plan your learning in 10 mins2024-11-06 00:03-\n"},"ğŸ¥·ğŸ½-jutsus/personal-growth":{"title":"personal growth","links":["ğŸ¥·ğŸ½-jutsus/bookshelf","ğŸ¥·ğŸ½-jutsus/desexualizing-your-brain-is-the-cheat-code-to-success"],"tags":["atlas"],"content":"personal growth\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourcebookshelf2024-11-05 02:06-desexualizing your brain is the cheat code to success2024-11-05 02:53-\n"},"ğŸ¥·ğŸ½-jutsus/plan-your-learning-in-10-mins":{"title":"plan your learning in 10 mins","links":[],"tags":["zettel","note-taking"],"content":"Plan Your Learning\nCaptures\n02:33\nS.E.E.D:\nS - set timer for 10 mins\nE - establish the key learning objectives. why learn this? what are the outcomes? what is essential?\nE - explore the map. scan headings, bold ones and images etc. focus on the parts that can answer the objectives.\nD - draw your thought process. gives feedback on your thought process and can help you know what you should work on more.\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/project-ideas":{"title":"project ideas","links":[],"tags":["zettel","software-dev","ai","machine-learning"],"content":"project ideas\nBuild GPT\nLetâ€™s build GPT: from scratch, in code, spelled out. - YouTube\nLLM Twin\nLLM Twin GitHub\nLLM Twin Medium\nIdea: connect your obsidian notes too, which can add to a more comprehensive LLM Twin.\nF1 Projects\nGitHub - Jared-Chan/f1ml: Formula One Race Lap-by-Lap Prediction with Machine Learning\n\nUse the OpenF1 API | Real-time and historical Formula 1 data because the API used in above project is deprecated.\n\nGitHub - TomWebster98/Race-Strategy-Analysis: My personal project for F1 race strategy analysis and visualisations, including â€œWhat made the difference?â€ reports/blogs.\nGitHub - chandanamulagund/Maximizing-Performance-Data-Analysis-of-Formula-1-Driver-and-Race-Data: Analysis of F1 races and their drivers\nGitHub - ChintanTrivedi/football_ai_commentary: AI generating real-time football commentary\n\nCheck-out: Live transcriptions of F1 races using Amazon Transcribe | AWS Machine Learning Blog\n\nGitHub - nesboonstra/f1_xo_project: Formula 1 Expected Overtakes Project\n\nDriver performance analysis plots based on above\n\nGitHub - larisoncarvalho/F1-Analytics-AI: This is a SQL Agent AI tool that can use natural language through an LLM to query a database and return relevant F1 race and qualifying statistics\nThe fastest driver in Formula 1 | AWS Machine Learning Blog\nBuild Your Own X\nBuild Your Own X\nGitHub - codecrafters-io/build-your-own-x: Master programming by recreating your favorite technologies from scratch.\nBuild your own Redis | CodeCrafters\nPython | CodeCrafters\nIdeas\nBuild a system where a given medium article link can be used to scrape and categorise it into pre defined categories by the user or maybe automatically too.\n\nGitHub - benthecoder/gpt3-blog-title: Using GPT-3 to help me get more ğŸ‘ on medium.com\n\nPercentage of news fakeness detection using RAG and news APIs\nFlashcard generation using LLM or rag system for my obsidian vault.\nFinal Year Project Idea: Build a system like Alexa and Jarwis that can work with tools and apps in your laptop and phone etc. Like an LLM voice agent.\n\nEfficient blending of voice and background music which I noticed wasnâ€™t good in the medito app. The medito app had options to choose which background music you needed along with guide voice. I noticed that the blending was pretty good but was distinct probably because they were just playing both sounds and not blending it. We can have a light model that doesnâ€™t need much space so we can have less costs and run it on mobile phones.\nforecasting model for your expense tracking.\n\nChatGPT - Obsidian LLM Knowledge Base this could be an excellent idea, spend some time refinign and building it.\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/project-kaizen":{"title":"project kaizen","links":[],"tags":["project"],"content":"project kaizen\nOverview\n\nObjective: To make you different person in 100 days.\nDeadline: Feb 13 2025\n\nMilestones\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDateDayDo Something to Improve MindDo Something to Improve BodyProduce SomethingDo Something that Makes you UncomfortableHealthy Diet05-11-2024Day-1meditationplayed badmintonshell aliasesnextcloud setup and reformatting vaultyes.06-11-2024Day-2\nLinks &amp; References\nThis 100 Day Challenge Changed My Lifeâ€¦ - YouTube"},"ğŸ¥·ğŸ½-jutsus/queue":{"title":"queue","links":["Arrays","Linked-List"],"tags":["zettel","dsa"],"content":"Queue\nSummary\n\nQueue is a linear data structure that offers a functionality that follows FIFO - First In First Out.\n\nIdea\n\nQueue follows FIFO which states that the first one to come in is also the first one to come out.\nTo ensure we follow this rule or functionality Queueâ€™s allow for addition of element at end of sequence(enqueue operation) and removal of elements from the start of sequence(dequeue operation).\nEnd of sequence is called the back, tail, rear of the Queue.\nStart of sequence is called the front, head of the Queue.\n\n\n\n\n                  \n                  Hint\n                  \n                \n\nBreadth First Search is implemented using Queue.\n\n\nImplementation\n\nSince Queue is a abstract data structure, it has to be implemented using another data structure as its base.\nSince Queue holds sequence of elements, the structures that come to mind are: Arrays and Linked List.\nSince Queues are dynamic I would say Linked Lists are a better option right off the bat, but lets look into the reasoning a little more.\n\nArrays vs Linked List for Implementation\nArrays:\n\nArrays are static data structures i.e we need to know the expected size of array beforehand.\nWhile insertion and removal at end in an array is O(1) time, insertion or removal at start of an array is still O(n) time because of the shifting that needs to be taken care of.\nHence enqueue would be O(1) time but dequeue would be O(n) time because after removal we need to shift the elements. This can be overcome by using a circular array.\nBut there is still a big problem looming behind this implementation and i.e the fact that when we enqueue and the corresponding memory is not available, then we need to copy the array and re-allocate it(O(n) time).\nItâ€™s still considered O(1) on average.\nThere can also be wastage of memory as we can never know that at any given time most of the elements are present in the queue.\n\nLinked List:\n\nAs I said, Linked List can be best implementation for a Queue.\nLinked Lists are dynamic and you donâ€™t have to know the size before hand.\nWe can maintain 2 pointers that point to the head and tail of the list which gets rid of the fact that we need to traverse.\nWe can make use of the pointers and enqueue and dequeue in O(1) not on average but all the time.\n\n\n\n\n                  \n                  Info\n                  \n                \n\nQueues are used in many places message queues, job scheduling, request &amp; response queuing in web servers etcâ€¦\n\n\nTime complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-OEnqueue/OfferO(1)Dequeue/PollO(1)FrontO(1)BackO(1)isEmptyO(1)\nEssential Qs\n\nImplement Stack using Queue\n\nRecommended Qs\n\nImplement Queue using Stacks\n\nTasks\n\n Permanent zettels\n Learn Circular Array just the basics.\n\n\nKey Terms\n\nEnqueue: addition of an element to end of queue.\nDequeue: removal of an element from start of queue.\n\nRelated Notes\n\nArrays\nLinked List\n\nReferences(links)\n\nQueue cheatsheet for coding interviews | Tech Interview Handbook\nTo Queue Or Not To Queue. When I first learned about backgroundâ€¦ | by Vaidehi Joshi | basecs | Medium\n"},"ğŸ¥·ğŸ½-jutsus/quick-sort":{"title":"quick sort","links":["Merge-Sort","Quick-Sort-vs-Merge-Sort","Arrays"],"tags":["zettel","dsa"],"content":"Quick Sort\nSummary\nDivide and Conquer Algorithm\nQuick sort is averagely O(n log n) but not always as the worst case is O(n^2) but Merge Sort is always O(n log n) so it is slightly better.\nComplexity\nTime\nWorst Case: O(n^2)\nBest and Average Case: O(n log n)\nSpace\nO(log n)\nGeneral Steps\nChoose pivot element (first, last or random)\nStore elements less than pivot in left subarray and vice versa\nCall quicksort recursively on left subarray\nCall quicksort recursively on right subarray\nCode Steps\nStep-1: Choose pivot element\nStep-2: Initialise pointers i at start of array and j at end of array.\nStep-3: i index increments until it finds an element that is greater than pivot\nStep-4: j index decrements until it finds an element that is less than pivot\nStep-5: if i &lt; j then swap(arr[i], arr[j])\nPut the greater number to the right of pivot and the lesser number to the left of pivot.\nStep-6: if j &gt; i it indicates that all elements smaller than pivot are to the left and vice verse.\nswap(arr[pivot], arr[j])\nStep-7: Split the array by pivot into left and right subarrays.\nStep-8: Repeat Steps 1 to 7 for left subarray.\nStep-9: Repeat Steps 1 to 7 for right subarray.\nCode\nfrom typing import List\n \ndef quickSort(arr: List[int], left: int, right: int):\n\tif left &lt; right:\n\t\tpartition = findPartition(arr, left, right)\n\t\tquickSort(arr, left, partition-1)\n\t\tquickSort(arr, partition+1, right)\n \n \ndef findPartition(arr: List[int], left: int, right: int) -&gt; int:\n\tpivot = left\n\ti = left\n\tj = right\n\twhile i &lt; j:\n\t\twhile i &lt;= j and arr[i] &lt;= arr[pivot]:\n\t\t\ti += 1\n\t\twhile i &lt;= j and arr[j] &gt;= arr[pivot]:\n\t\t\tj -= 1\n\t\tif i &lt; j:\n\t\t\tarr[i], arr[j] = arr[j], arr[i]\n\tarr[pivot], arr[j] = arr[j], arr[pivot]\n\treturn j\n \narr: List[int] = [54, 29, 93, 17, 77, 31]\nquickSort(arr, 0, 5)\nprint(arr)\n\n\n\n                  \n                  Important\n                  \n                \n\ni &lt;= j must be used inside the while loop because we need to stop the iteration as soon as i and j cross each other and not go on until the condition is satisfied.\n\n\nQuestions\nWhich is better merge or quick sort? A: Quick Sort vs Merge Sort\nRelated Notes\nArrays\nMerge Sort"},"ğŸ¥·ğŸ½-jutsus/recursion":{"title":"recursion","links":["Stack","Arrays","Strings","Quick-Sort","Merge-Sort"],"tags":["zettel","dsa"],"content":"Recursion\nSummary\n\nRecursion is a method for solving computational problems where the solution to the problem depends on solutions of smaller instances of the problem.\n\n\n\n                  \n                  Quote\n                  \n                \n\nâ€œRecursion is defining a problem in terms of smaller versions of itselfâ€\n\n\nThree Parts: A recursion problem has 3 parts\n\nBase Case: solution to the simplest possible problem.\nWork towards Base case: for any problem the base case is the final goal.\nRecursive call: calling ourselves where each call solves the problem on a smaller version but on the same algorithm or code.\n\n\n\n                  \n                  Tip\n                  \n                \n\nConsider recursion as having a weird gift box that contains a solution to your problem, but when you open the box you have many other boxes. There are 2 types of boxes:\n\nBox that contains other boxes a.k.a Recursive boxes\nBox that contains a value a.k.a Base case box\nWhenever you are solving a seemingly recursive problem, follow these 2 steps:\nStep-1: Recognise base case and recursive case\nStep-2: Map out a decision tree for the recursive calls\n\n\n\n\nTail Recursion\nIt is a recursive function in which the last statement executed by the function is the recursive call after this there is no other statement to execute.\n\n\n                  \n                  Example\n                  \n                \n\ndef prints(n):\n\tif (n &lt; 0):\n\t\treturn\n\tprint(&quot;n:&quot;, n)\n\tprints(n-1)\nprints(4)\nIn the example above the last statement executed by the function is the recursive call hence this function is a tail-recursion.\n\n\nWhy is tail-recursion optimal?\n\nTail-recursive functions can be optimised by the compiler.\nCompilers use a [[[[stack]]]] to execute recursive procedures. Every time a recursive procedure is called the compiler pushes the recursive call with the arguments to the Stack (also adds the no. of statements to execute after recursive call). After a recursive call has finished execution it is popped out.\nThis usually leads to more [[stack]] depth in case of non-tail-recursive functions.\nSome programming languages implement tail-call-optimisation - TCO which leads to constant auxiliary space instead of the usual O(N).\n\nExample:\nFactorial: We all know the recursive function for solving factorial of a number.\ndef fact(n):\n\tif n == 0:\n\t\treturn 1\n\treturn n * fact(n-1)\nprint(fact(5))\n\nBut this is not a tail-recursive-function. Even though, it looks like the last statement executed is the recursive call but the thing is after we get the output of fact(n-1) it has to multiplied with n to get out final output. Hence, it makes this function non-tail-recursive.\n\n\n\nInstead of multiplying n with factorial of n-1 which leads to non-tail-recursion, we can calculate the factorial at each step and store it in a extra variable which can be returned directly.\n\ndef fact_tail(n, acc = 1):\n\tif n == 0:\n\t\treturn acc\n\treturn fact_tail(n-1, n*acc)\nprint(fact_tail(5))\n\nIn this case there is no statement to be executed after the recursive call. Hence this makes it tail-recursive, that is there is no need of a Stack trace cause the output is computed and passed at every step.\n\n\n\n\n                  \n                  Note\n                  \n                \n\nPython doesnâ€™t support Tail-Call-Optimisation(TCO) hence it still creates a Stack trace for the non-tail-recursive-function we wrote in Python above. This is the reason why we have used the linereturn fact_tail(n-1, n*acc) as it needs to return the result to previous calls.\n\n\nMemoization\nIn some cases, you may be computing the result for previously computed inputs. Letâ€™s look at the Fibonacci example again.Â fib(5)Â callsÂ fib(4)Â andÂ fib(3), andÂ fib(4)Â callsÂ fib(3)Â andÂ fib(2).Â fib(3)Â is being called twice! If the value forÂ fib(3)Â is memoized and used again, that greatly improves the efficiency of the algorithm and the time complexity becomes O(n).\nEssential Qs\n\nGenerate Parenthesis\nCombinations\nSubsets\n\n\nTasks\n\n Create independent zettels\n\nKey Terms\n\nRecursion: defining a problem in terms of smaller versions of itself\nBase Case: the simplest version of a problem that can compound to give you the result of a bigger problem\nRecursive Call: the call to itself but with a smaller version of the current problem\nTail Recursion: recursive function in which the last statement is the recursive call\nTail Call: the recursive call as the last statement in tail-recursive-functions\nTCO - Tail Call Optimisation: some programming languages optimise the tail calls by not constructing the Stack trace leading to constant auxiliary space used by the recursive-function\n\nRelated Notes\n\nArrays\nStrings\nQuick Sort\nMerge Sort\n\nReferences(links)\n\nRecursion cheatsheet for coding interviews | Tech Interview Handbook\nProgramming - Recursion\nTail Recursion - Section 2 and Homework 2 | Coursera\nRecursion for Beginners - Fibonacci Numbers - YouTube\nWhat is Tail Recursion - GeeksforGeeks\nChatGPT | Clarification of return statement &amp; TCO in Python\n"},"ğŸ¥·ğŸ½-jutsus/reserach-papers-to-implement":{"title":"reserach papers to implement","links":["03-resources/Research-Papers/Attention-Is-All-You-Need.pdf"],"tags":["zettel","ai","machine-learning"],"content":"reserach papers to implement\nFundamentals\nAttention is All You Need Attention Is All You Need.pdf\nInterests\nBERT: Pre-training of Deep Bidirectional Transformers for Language Understanding | Papers With Code\nBayesian Analysis of Formula One Race Results: Disentangling Driver Skill and Constructor Advantage | Papers With Code\nAMZ Driverless: The Full Autonomous Racing System | Papers With Code\nA Dual-Stage Attention-Based Recurrent Neural Network for Time Series Prediction | Papers With Code\nAA-Forecast: Anomaly-Aware Forecast for Extreme Events | Papers With Code\niTransformer: Inverted Transformers Are Effective for Time Series Forecasting | Papers With Code\nGraph Neural Networks for Social Recommendation | Papers With Code\nIncrementally Improving Graph WaveNet Performance on Traffic Prediction | Papers With Code\nKGAT: Knowledge Graph Attention Network for Recommendation | Papers With Code\nQA-GNN: Reasoning with Language Models and Knowledge Graphs for Question Answering | Papers With Code\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/searching--and--sorting":{"title":"searching & sorting","links":["Binary-Search","Tim-Sort","Stability-of-Sorting-Algorithms","Arrays","Strings","Quick-Sort","Merge-Sort","Quick-Sort-vs-Merge-Sort","Recursion"],"tags":["zettel","dsa"],"content":"Searching &amp; Sorting\nSummary\n\nSorting is the process of rearranging elements either in ascending or descending order in a data structure.\nSearching is the process of looking in a data structure if what we want is present and at what index.\n\nMost sorting algorithms take O(N^2) time complexity and there are some optimised algorithms that take O(n log n). These algorithms are the ones that are used as default sorting algorithms in most programming languages.\nA typical search for an element in a data structure would take O(n) time as we are looking into all the elements in the data structure. But an optimal way to do it would be to sort the values first and do a Binary Search which typically uses O(log n) time by intelligently choosing the right half to search in.\n\n\n                  \n                  Tip\n                  \n                \n\nBonus points if you can name the languageâ€™s default sorting algorithm. \nPython: Tim Sort\n\n\nTime complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithmTimeSpaceBubble sortO(n2)O(1)Insertion sortO(n2)O(1)Selection sortO(n2)O(1)QuicksortO(nlog(n))O(log(n))MergesortO(nlog(n))O(n)HeapsortO(nlog(n))O(1)Counting sortO(n + k)O(k)Radix sortO(nk)O(n + k)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithmBig-OBinary SearchO(log(n))\nEssential Qs\n\nBinary Search\nSearch in Rotated Sorted Array\n\nTasks\n\n Learn Heap Sort\n Learn Counting Sort\n Learn Radix Sort\n\n\nQuestions\n\nWhich one is better for implementation purposes?\n\nKey Terms\n\nStability of Sorting Algorithms: It determines if the algorithm maintains the original ordering of elements even after sorting.\nInternal vs External: Sorting algorithms that use the RAM are called internal sorting algorithms and those that use the disk are called external sorting algorithms.\nComparison vs Non-Comparison: The name says it all.\n\nRelated Notes\n\nArrays\nStrings\nQuick Sort\nMerge Sort\nQuick Sort vs Merge Sort\nBinary Search\nRecursion\n\nReferences(links)\n\nSorting and searching cheatsheet for coding interviews | Tech Interview Handbook\nSorting Out The Basics Behind Sorting Algorithms | by Vaidehi Joshi | basecs | Medium\n"},"ğŸ¥·ğŸ½-jutsus/sliding-window":{"title":"sliding window","links":["Arrays","Two-Pointers"],"tags":["zettel","dsa"],"content":"Sliding-Window\nSummary\n\nVariant of same direction 2 pointer problems.\nFunction performs on the entire interval rather than just the two positions.\nKeep track of the value of the window and slide the window along the array.\n\nSteps\n\nCompute the initial result of the window.\nSlide the window along the array either by increasing right or left or both.\nRecompute the result and check if optimal conditions is met.\nElse continue\n\nProblems\n\nSubstring\nSubarray\nmax/longest sequence\nsubsequence\n\nTemplate\nFixed Window:\ndef sliding_window(input, window_size):\n\tans = 0\n\tfor i in range(window_size):\n\t\tans = compute ans\n\toptimal_ans = ans\n\tfor right in range(window_size, len(input)):\n\t\tleft = right - window_size\n\t\tremove input[left] from window(ans)\n\t\tadd input[right] from window(ans)\n\t\toptimal_ans = optimal(ans, optimal_ans)\n\treturn optimal_ans\n\nRelated Notes\n\nArrays\nTwo-Pointers\n\nReferences(links)\n\nSubarray Sum - Fixed\nAlgoMonster: The Structured Path to Success on LeetCode Data Structure &amp; Algorithm Interviews\n"},"ğŸ¥·ğŸ½-jutsus/software-dev":{"title":"software dev","links":["ğŸ¥·ğŸ½-jutsus/SyncWise","ğŸ¥·ğŸ½-jutsus/1.-python","ğŸ¥·ğŸ½-jutsus/bookshelf","ğŸ¥·ğŸ½-jutsus/django-rest-framework","ğŸ¥·ğŸ½-jutsus/project-ideas","ğŸ¥·ğŸ½-jutsus/ai-roadmap"],"tags":["atlas"],"content":"software dev\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourceSyncWise2024-11-05 02:23-1. python2024-11-05 02:11-bookshelf2024-11-05 02:06-django-rest-framework2024-11-05 02:34SyncWiseproject ideas2024-11-05 02:04-ai roadmap2024-11-05 02:08-\n"},"ğŸ¥·ğŸ½-jutsus/stability-of-sorting-algorithms":{"title":"stability of sorting algorithms","links":["Searching--and--Sorting"],"tags":["zettel","dsa"],"content":"Stability of Sorting Algorithms\nSummary\nRefers to whether the sorting algorithm follows the original ordering of elements in the data structure.\n\n\n                  \n                  Example\n                  \n                \n\nif we have two 4â€™s in an array that is green and red, if the green comes before red in original array and this follows in the sorted array then it is Stable algorithm else Unstable algorithm.\n\n\n\n\nRelated Notes\n\nSearching &amp; Sorting\n\nReferences(links)\n\nSorting Out The Basics Behind Sorting Algorithms | by Vaidehi Joshi | basecs | Medium\n"},"ğŸ¥·ğŸ½-jutsus/stack":{"title":"stack","links":["Queue","Arrays","Linked-List","Recursion"],"tags":["zettel","dsa"],"content":"Stack\nSummary\n\nA stack is a abstract data type that follows LIFO - Last In First Out.\n\nIdea\nStack literally means a stack of items. I remember in school when I used to submit books(stack of books) I always used to put my book in the middle because if mine is the last one on top then that book is the first one that is picked by the teacher.\n\n\n\n                  \n                  Note\n                  \n                \n\nOperations on stack occur only in one direction i.e at the top. Be it push or a pop, it always happens at the top.\n\n\nImplementation\n\n\nJust like Queue, we can implement stack using Arrays or Linked List.\nWe have the same problems as we have for Queue implementation using Arrays.\n\nSince stack can grow infinitely without any upper limit, Arrays eventually canâ€™t find a contagious memory of that size and hence it raises a stack overflow exception.\nThis is what happens when we have an infinite Recursion.\n\n\nIn the case of a Singly Linked List, we can add or remove elements from the head node which would always be O(1) time complexity. And we can always add a node as long as there is memory left (if not then there is a major memory problem).\n\n\nFunctions\n\npush: add element to the top of stack.\npop: remove element from the top of stack.\ntop (peek): returns the value of top but doesnâ€™t pop it.\nisEmpty: check if stack is empty.\nsize: returns size of stack.\n\n\n\n                  \n                  Example\n                  \n                \n\n\nundo / redo\nbrowser history\ncall stacks\n\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nStacks are used to implement depth-first-search.\n\n\nTime complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-OTop/PeekO(1)PushO(1)PopO(1)isEmptyO(1)SearchO(n)\nEssential Qs\n\nValid Parentheses\nImplement Queue using Stacks\n\nRecommended Qs\n\nImplement Stack using Queue\n\nTasks\n\n Permanent zettels.\n Explain Implementation properly\n\n\nKey Terms\n\nLIFO:  the item that comes in first is the one to go out.\nStack Overflow: an exception that occurs when the stack array can no longer find contagious memory.\n\nRelated Notes\n\nArrays\nLinked List\nRecursion\nQueue\n\nReferences(links)\n\nStack cheatsheet for coding interviews | Tech Interview Handbook\nStacks and Overflows. When I was first learning to codeâ€¦ | by Vaidehi Joshi | basecs | Medium\n"},"ğŸ¥·ğŸ½-jutsus/strings":{"title":"strings","links":["Arrays"],"tags":["zettel","dsa"],"content":"Strings\nSummary\nVery similar to Arrays because they are sequence of characters while Arrays are sequence of a single data type.\nCommon Things\nCommon data structures for looking up strings\n- Trie/Prefix tree\n- Suffix tree\nCommon algorithms for searching substrings\n- Rabin-Karp Algorithm\n- KMP\nTime Complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-OAccessO(1)SearchO(n)InsertO(n)RemoveO(n)\nOperations Involving Another String\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationBig-ONoteFind substringO(n.m)This is the most naive case. There are more efficient algorithms for string searching such as theÂ KMP algorithmConcatenating stringsO(n + m)SliceO(m)Split (by token)O(n + m)Strip (remove leading and trailing whitespaces)O(n)\nTechniques\nCounting characters\nString of unique characters\nAnagram\nPalindrome\nEssential Qs\nValid Anagram\nValid Palindrome\nLongest Substring without repetitions\n\nQuestions\nAre Rabin-Karp and KMP asked in interviews? Are they important algorithms?\nHow does a trie work?\nRelated Notes\nArrays\nReferences(links)\nString cheatsheet for coding interviews | Tech Interview Handbook"},"ğŸ¥·ğŸ½-jutsus/syncwise-progress-tracking":{"title":"syncwise progress tracking","links":["ğŸ¥·ğŸ½-jutsus/SyncWise","ğŸ¥·ğŸ½-jutsus/GradeSync","ğŸ¥·ğŸ½-jutsus/django-rest-framework"],"tags":["progress-tracking"],"content":"Progress Tracker\nPROJECT: SyncWise\nMilestones\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMilestoneDescriptionDue DateCompleted DateStatusMigrate from fastapi to djangoMigrating eduinsights built using fastapi to GradeSync which uses django-rest-framework.2024-10-27NAon goingML ModelsTraing ML models for sgpa forecasting and risk-indicator2024-11-10NApendingResult Analysis DashboardsHelp vikki build the result analysis dashboards using react.NANApendingBuild a RAG agentLearn and build a RAG agent for solving doubts based on the context of notesNANApending\nWeekly Updates\nWeek of [Date]\nAchievements:\n\nAchievement 1\nAchievement 2\n\nChallenges:\n\nChallenge 1\nChallenge 2\n"},"ğŸ¥·ğŸ½-jutsus/synzwise-features":{"title":"synzwise features","links":["ğŸ¥·ğŸ½-jutsus/SyncWise"],"tags":["documentation"],"content":"synzwise features\nPROJECT: SyncWise\nFeatures List\nCore Features\nSingle Credential\nGradeSync\n\nResults Scraping\nPdf Extraction\nAnalysis Dashboards\nSGPA Forecasting\nRisk-Indicator\n\nStudySync\n\nChatbot using RAG\nTicketing System + Chatting\n\nAdditional Features\n\n\n"},"ğŸ¥·ğŸ½-jutsus/system-design-resources":{"title":"system design resources","links":["03-resources/Articles/Big-Archive-System-Design-2023.pdf","03-resources/Books/AlgoMaster.io-System-Design-Interview-Handbook.pdf"],"tags":["zettel","interview-prep"],"content":"system design resources\nWebsites\n\nCrack System Design Interview\nGitHub - karanpratapsingh/system-design: Learn how to design systems at scale and prepare for system design interviews\nbooknotes/system-design at master Â· preslavmihaylov/booknotes Â· GitHub\n\nPDFs\n\n\nBig Archive System Design 2023.pdf\nAlgoMaster.io System Design Interview Handbook.pdf\n\n\nRelated Notes\nReferences(links)"},"ğŸ¥·ğŸ½-jutsus/system-design":{"title":"system design","links":["ğŸ¥·ğŸ½-jutsus/how-uber-computes-ETA"],"tags":["atlas"],"content":"system design\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourcehow uber computes ETA2024-11-05 23:31-\n"},"ğŸ¥·ğŸ½-jutsus/tim-sort":{"title":"tim sort","links":["Big-O-Notation","Merge-Sort","Quick-Sort","Binary-Insertion-Sort","Searching--and--Sorting","Arrays","Strings","Recursion"],"tags":["zettel","dsa"],"content":"Tim Sort\n\nSummary\n\nTim sort is a hybrid, stable sorting algorithm designed by Tim Peters in 2002, it combines merge and insertion sort to efficiently sort.\n\nDetailed Explanation\n\nLetâ€™s try to understand why the need for a new sorting algorithm was there?\nBefore we try to get to the point, we need to know that in Big-O Notation there is a catch i.e it denotes only the highest degree and ignores constants.\nWhile Merge Sort, Quick Sort, and Heap Sort are all sorting algos that execute in O(n.log n) time they have differed constants which can make one better than the other in certain situations.\nTime Complexity: O(C. n. log n + â€¦)\n\nWhere C is:\n\nhigh for Quick Sort â†’ Cq = left, right, pivotâ€¦ but it has locality of reference\nlow for Merge Sort but it needs O(n) extra auxiliary space\nhigh for Heap Sort, even though it needs no extra space but it has no locality of reference because the compiler doesnâ€™t know which index it will next access\n\n\n\n\n\n\n\n                  \n                  Info\n                  \n                \n\nAmong sorting techniques that take O(n^2 time, insertion sort is an algo that has:\n\n(Ci. n^2) &lt; (C. n.log n) for smaller input size usually between 32 to 64.\nHence Insertion sort is used in Tim Sort by taking this into account.\n\n\n\nIdea\n\nThe idea of Tim Sort is to combine the power of insertion sort for small data and the merging of Merge Sort.\nLetâ€™s take this progressively, Iâ€™ll take examples or explain concepts from the basic overview of Tim sort to detailed overview.\nThe basic idea of Tim sort is:\n\nStep-1: split the data structure into equal size chunks of size 32 to 64. Chunks â†’ Runs\nStep-2: chunks are sorted using insertion sort (as insertion sort is fast for smaller sizes between 32 to 64)\nStep-3: these sorted chunks are now recursively merged like in Merge Sort.\n\n\nThe advantage is that when using Merge Sort we are getting down the splits into size 2 or 1 but in the case of splitting them into equal chunks of 64 (example) we can reduce the tree depth by five levels because 64 = 2^6.\n\n\n\nBut this is still not fully efficient, so Tim Peters came up with a new idea where he will intelligently split the chunks into sizes between 32 to 64 instead of directly doing it which cause some localities to be missed.\nAt the same time he came across the idea of splitting into chunks by sorting it by using Binary Insertion Sort.\n\n\n\nIn this example, we have first divided the array into chunks by using Binary Insertion Sort and then recursively merged them with the Merge Sort logic.\nWhy is this better than splitting into fixed chunk sizes because it decreases the number of chunks by combining subarrays that follow increasing or decreasing order making it easy to group chunks that have most elements in order.\nAnd it makes sure to take advantage of Binary Insertion Sort which is optimal for the defined chunk size (32 - 64).\nThis ultimately decreases the number of chunks to merge and also the tree depth.\nIf we had split the array it equal chunks of size 3 then we would have got 4 but by using Binary Insertion Sort we got only 3.\n\nTime Complexity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithmTime ComplexityBestAverageWorstQuick SortÎ©(n*log(n))Î¸(n*log(n))O(n^2)Merge SortÎ©(n*log(n))Î¸(n*log(n))O(n*log(n))Tim SortÎ©(n)Î¸(n*log(n))O(n*log(n))\n\nKey Terms\n\nLocality of Reference: It is a phenomenon where the compiler can cache the access to elements based on the pattern of accessing elements in the algo.\n\nRelated Notes\n\nSearching &amp; Sorting\nMerge Sort\nArrays\nStrings\nRecursion\nBinary Insertion Sort\n\nReferences(links)\n\nThe FASTEST sorting algorithm: Part 1 - TimSort - YouTube\nThe FASTEST sorting algorithm: Part 2 - Binary Insertion Sort - YouTube\nTim Sort - javatpoint\nTim Sort. Introduction and Background | by Muskan Vaswan | Medium\nTimSort - Data Structures and Algorithms Tutorials - GeeksforGeeks\n"},"ğŸ¥·ğŸ½-jutsus/tools":{"title":"tools","links":["ğŸ¥·ğŸ½-jutsus/mermaid-diagrams-docs"],"tags":["atlas"],"content":"tools\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileDateSourcemermaid diagrams docs2024-11-06 00:02-\n"},"ğŸ¥·ğŸ½-jutsus/topological-sorting-using-dfs":{"title":"topological sorting using dfs","links":["ğŸ¥·ğŸ½-jutsus/topological-sorting","ğŸ¥·ğŸ½-jutsus/graphs-depth-first-search","ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs","Stack"],"tags":["zettel","dsa"],"content":"topological sorting using dfs\nWe know that topological sorting is nothing but making sure we visit a node only when we know we have visited every single node that leads up to it.\nSince graphs depth first search is very good at following a path and when it reaches a leaf node it backtracks. We can take this mechanism to our advantage. We can use a stack to store the ordering in reverse order. Where we push to stack only when we know every neighbouring node of the cur node is visited or it is the leaf node.\nvisited = set()\nstack = []\n \ndef dfs(node):\n\tvisited.add(node)\n\tfor neighbour in get_neighbours(node):\n\t\tif neighbour not in visited:\n\t\t\tdfs(neighbour)\n\t# after visiting all its neighbours we can push to stack. \n\tstack.append(node)\n \n# make sure we visit all paths available\nfor node in graph:\n\tif node not in visited:\n\t\tdfs(node)\n \nprint(&quot;Ordering: &quot;, stack[::-1])\nWe use the for loop to visit the nodes because there can be multiple nodes (like root nodes with no edge leading up to it). To counter this we need to make sure we donâ€™t miss any node.\nThe actual ordering is the reverse of the stack because notice that in graphs depth first search we are reaching the deepest level and then backtracking. We are essentially going deep and then backtracking hence we are constructing the topological sorting in reverse i.e from the leaf nodes.\n\n\n                  \n                  Tldr\n                  \n                \n\n**See it this way, what does graphs depth first search do?\nA: It follows a path and backtracks when it visits a node that is already visited\nIn the path it takes what is the last node it visits?\nA: A leaf node (or node that has visited all its neighbours).\nWhat is the position of this node in topological sorting ?\nA: It is one of the last nodes in the order to be visited hence we are constructing the topological sorting in reverse. **\n\n\n\nRelated Notes\ngraphs\ngraphs depth first search\ntopological sorting\ndirected acyclic graphs\nStack\nReferences(links)\nPerplexity | Topological Sorting using dfs"},"ğŸ¥·ğŸ½-jutsus/topological-sorting-using-khan's-algo":{"title":"topological sorting using khan's algo","links":["ğŸ¥·ğŸ½-jutsus/topological-sorting","ğŸ¥·ğŸ½-jutsus/graphs-breadth-first-search","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/topological-sorting-using-khan's-algo","Queue","ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs"],"tags":["zettel","dsa"],"content":"topological sorting using khanâ€™s algo\nKhanâ€™s algo for topological sorting implements a mechanism that is similar to graphs breadth first search. They may not be similar completely but they use the core mechanism.\nWe should be aware of these concepts of directed graphs to understand Khanâ€™s algo better:\n\nin-edge: an edge pointing to or coming into(â€œinâ€) the node.\nout-edge: an edge pointing away or going â€œoutâ€ from the node.\nin-degree: the count of in-edges coming into the node.\nout-degree: the count of out-edges going away from the node.\n\nThe in-edge and in-degree are important concepts here because we know topological sorting order depends on it. If a node has in-degree of 0 then we know this is the node that we visit first.  \nIf we take this in the context of trees, we can see that the order for topological sorting would be root node first and then the nodes in the next level and goes onâ€¦\nwe can notice that whatever we mapped above is similar to how graphs breadth first search works, since graphs have more freedom compared to trees, graphs breadth first search alone canâ€™t help us.\nHence khanâ€™s algo combines the graphs breadth first search and the in-degree concepts together.\nQ: How does khanâ€™s algo do it?\nA: We know this ^6e873e, what we also should know is that once we have visited the node with in-degree 0, we can decrement all its neighbours in-degree by 1 and remove the node. As we do this one-by-one we get the right order.\nHow can we do this? This is where the graphs breadth first search comes. We need to use a Queue to keep track of the nodes that have in-degree 0, this way we can visit this node add it to the order and then decrement the in-degree of its neighbours and remove it.\nSteps:\n\ncompute the in-degree of all the nodes. add the nodes that have in-degree 0 to queue to visit them.\npop each node from the Queue, decrement the in-degree of its neighbours by 1. if any of the neighbours in-degree becomes 0 add it to the Queue\ndo this until Queue is empty.\n\n\n\n                  \n                  bfs vs khan&#039;s algo \n                  \n                \n\nIn graphs breadth first search we add all nodes to the Queue as we traverse, but in topological sorting using khanâ€™s algo we add only the nodes that have in-degree 0 to the Queue.\n\n\ndef find_indegree(graph):\n\tindegree = {node: 0 for node in graph}\n\tfor node in graph:\n\t\tfor neighbour in get_neighbours(node):\n\t\t\tindegree[neighbour] += 1\n\treturn indegree\n \ndef topo_sort(graph):\n\tq = deque()\n\tres = []\n\tindegree = find_indegree(graph)\n\tfor node in indegree:\n\t\tif indegree[node] == 0:\n\t\t\tq.append(node)\n\twhile q:\n\t\tnode = q.popleft()\n\t\tres.append(node) # node with in-degree 0\n\t\tfor neighbour in get_neighbours(node):\n\t\t\tindegree[neighbour] -= 1\n\t\t\tif indegree[neighbour] == 0:\n\t\t\t\tq.append(neighbour)\n\treturn res id len(res) == len(graph) else None\n\nRelated Notes\ngraphs\ntrees\ngraphs breadth first search\nQueue\ndirected acyclic graphs\ntopological sorting\nReferences(links)\nTopological Sort Introduction"},"ğŸ¥·ğŸ½-jutsus/topological-sorting":{"title":"topological sorting","links":["ğŸ¥·ğŸ½-jutsus/directed-acyclic-graphs","ğŸ¥·ğŸ½-jutsus/graphs","ğŸ¥·ğŸ½-jutsus/topological-sorting-using-dfs","ğŸ¥·ğŸ½-jutsus/topological-sorting-using-khan's-algo"],"tags":["zettel","dsa"],"content":"topological sorting\nTopological sorting is a way of ordering directed acyclic graphs, which is quite important since directed acyclic graphs are used extensively and the ordering of the nodes is very important.\ntopological sorting just orders the vertices based on the interconnectedness of the edges. It makes sure that a vertex/node is only visited after all the vertices leading up to it is visited. NOTE: Do not confuse with logic of topological sorting algorithm\ngraph LR;\n\tA --&gt; B\n\tA --&gt; C\n\tB --&gt; D\n\tC --&gt; D\n\tD --&gt; E\n\nwhat the above statement means is that vertex D can only be visited after B and C vertices are visited. And the ordering is not exactly unique because it only depends on whether the vertices leading up to a vertex are visited or not.\ntopological ordering for above graph:\n\nA - B - C - D - E\nA - C - B - D - E\n\n\n\n                  \n                  Note\n                  \n                \n\nTopological sorting doesnâ€™t work for direct graphs with cycles, just think of it.\n\n\nThere are two ways to implement it:\n\ntopological sorting using dfs\ntopological sorting using khanâ€™s algo\n\n\nRelated Notes\ngraphs\ndirected acyclic graphs\ntopological sorting using dfs\ntopological sorting using khanâ€™s algo\nReferences(links)\nSpinning Around In Cycles With Directed Acyclic Graphs | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/tree-depth-traversal-use-cases":{"title":"tree depth traversal use cases","links":["ğŸ¥·ğŸ½-jutsus/tree-depth-traversals","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees","Trees","Searching--and--Sorting"],"tags":["zettel","dsa"],"content":"Depth Traversal Use cases\nSummary\nWe know tree depth traversals have different ordering and each of these ordering have their own unique use cases that help us for efficient operations.\nPre-Order root â†’ left â†’ right\nTree Copying: When copying trees we would like to visit the root nodes first and then left and right nodes hence pre-order traversal helps.\nEvaluating Prefix Expressions\nCreating Prefix Notation: converting binary tree to prefix notation.\nDirectory Structure: when representing directory structure as a tree we would like to list the folders before the files.\nIn-Order left â†’ root â†’ right\n\n\n                  \n                  Tip\n                  \n                \n\nIn-Order is closely related to binary trees and binary search trees\n\n\nSorted Output: to get the elements in sorted order in a binary search tree.\nBST Validation: validate whether all nodes in a BST follow the rule of BST.\nFinding Kth smallest/largest element\nPost-Order left â†’ right â†’ root\n\n\n                  \n                  Tip\n                  \n                \n\nPost-Order is closely related to dependency management.\n\n\nTree Deletion: to safely delete a tree we need to first delete its children and then the root to avoid dangling nodes.\nPostfix Expression Trees\nDependency Resolution: situations where dependencies must be resolved before executing a task (node).\n\n\nRelated Notes\ntrees\ntree depth traversals\nbinary trees and binary search trees\nSearching &amp; Sorting\nReferences(links)\nMastering Binary Tree Traversals: A Comprehensive Guide | by Adam DeJans Jr. | Plain Simple Software | Medium"},"ğŸ¥·ğŸ½-jutsus/tree-depth-traversals":{"title":"tree depth traversals","links":["ğŸ¥·ğŸ½-jutsus/trees","Stack","ğŸ¥·ğŸ½-jutsus/tree-depth-traversal-use-cases","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees","Searching--and--Sorting","Recursion"],"tags":["zettel","dsa"],"content":"Tree Depth Traversals\nSummary\nSince trees are unstructured data structures and unique. The way we can access the nodes is by traversing in a unique way, one such way is to traverse by depth.\nThe overall algorithm of tree depth traversals more or so remains the same, but the order in which we process the nodes can be different.\n\n\n                  \n                  Important\n                  \n                \n\nDepth Traversal involves using a Stack because the node that entered last is the one that must be popped out.\n\n\nTypes of Depth Traversals\n\nPre-Order: root â†’ left â†’ right\nex: 1, 7, 2, 6, 5, 11, 9, 9, 5\nIn-Order: left â†’ root â†’ right\nex: 2, 7, 5, 6, 11, 1, 9, 5, 9\nPost-Order: left â†’ right â†’ root\nex: 2, 5, 11, 6, 7, 5, 9, 9, 1\n\n\n                  \n                  Important\n                  \n                \n\nIn-Order Traversal of a binary tree is insufficient to uniquely serialise a tree. Pr-order or post-order traversal is required.\n\n\nRecursive Code\ndef depthTraverse(root):\n\t# Base case: when node is None\n\tif not root:\n\t\treturn\n\tprint(root.val) # Pre-Order\n\tdepthTraverse(root.left)\n\t# print(root.val) # In-Order\n\tdepthTraverse(root.right)\n\t# print(root.val) # Post-Order\n\n\n                  \n                  Use\n                  \n                \n\ntree depth traversal use cases\n\n\nTasks\n\n Implement each order traversal iteratively as a bonus.\n\n\nRelated Notes\ntrees\ntree depth traversal use cases\nbinary trees and binary search trees\nSearching &amp; Sorting\nRecursion\nReferences(links)\nMastering Binary Tree Traversals: A Comprehensive Guide | by Adam DeJans Jr. | Plain Simple Software | Medium"},"ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal":{"title":"tree level order traversal","links":["Queue","ğŸ¥·ğŸ½-jutsus/level-order-traversal-dry-run","ğŸ¥·ğŸ½-jutsus/level-order-traversal-by-level-dry-run","Arrays","Linked-List","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees"],"tags":["zettel","dsa"],"content":"Level Order Traversal\nSummary\nLevel Order Traversal as the name suggests, we traverse the tree by visiting every node in each level. We always go from left to right and hence it is also called breadth first search.\n\n\n                  \n                  Important\n                  \n                \n\nLevel Order Traversal involves using a Queue because first node that enters is the first node to come out.\n\n\n\nIterative Code\nq = deque()\nq.append(root)\nwhile q:\n\tnode = q.popleft()\n\tprint(node.val)\n\tif node.left:\n\t\tq.append(node.left)\n\tif node.right:\n\t\tq.append(node.right)\n\nCheck this out: level order traversal dry run\n\nIterative Code by Level\nq = dequeu()\nq.append(root)\nres = []\nwhile q:\n\tlevel = []\n\tfor _ in range(len(q)): # len(q) = no. of root nodes at that level\n\t\tnode = q.popleft()\n\t\tlevel.append(node.val)\n\t\tif node.left:\n\t\t\tq.append(node.left)\n\t\tif node.right:\n\t\t\tq.append(node.right)\n\tres.append(level)\nprint(res) # prints each levels nodes.\n\nCheck this out: level order traversal by level dry run\n\nUse Cases\nSerialisation: serialising a binary tree into a linear data structure like Arrays or Linked List.\nFind min depth: first leaf node encountered represents the min depth of the tree because we go level by level.\nTree modification: of all nodes at a certain level of binary tree.\n\nRelated Notes\ntrees\nbinary trees and binary search trees\nlevel order traversal dry run\nlevel order traversal by level dry run\nReferences(links)\nMostly on my own."},"ğŸ¥·ğŸ½-jutsus/trees":{"title":"trees","links":["Recursion","ğŸ¥·ğŸ½-jutsus/types-of-trees","Linked-List","ğŸ¥·ğŸ½-jutsus/tree-depth-traversals","ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal","ğŸ¥·ğŸ½-jutsus/balanced-vs-unbalanced-trees","ğŸ¥·ğŸ½-jutsus/trees","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees","Searching--and--Sorting"],"tags":["zettel","dsa"],"content":"Trees\nSummary\nTrees are abstract non-sequential data structures that are really just a bunch of nodes and links that are connected to one another.\ntrees are undirected and connected acyclic graphs, they are acyclic because they do not contain cycles or loops.\ntrees are a recursive data structure because each node is a root node of its own subtree. Hence Recursion is a useful technique for traversal of a tree.\n\nTerms\nRoot: the parent of all nodes that is at the top of the tree.\nlink/edges: are the connections between 2 nodes.\nchild: a node that has a parent, all nodes are child except the root.\nparent: a node that has children, all nodes except leaf nodes.\nsiblings: nodes that are children of the same node.\ninternal: any node that has a child node, all parent nodes.\nleaf: a node that has no child.\n\nCharacteristics\n\nIf a tree has n nodes then it will always have (n-1) edges/links. Why? because there is no link connecting to the root node.\n\n\nTrees contain smaller trees within themselves often referred to as subtrees.\n\n\n\n                  \n                  Note\n                  \n                \n\nDepth of a node: how far away is the node from the root of the tree?\nHeight of a node: how far is this node from the farthest away leaf? (Remember: we are turning the tree upside down in CS, hence height is determined this way.)\n\n\n\n\n                  \n                  Important\n                  \n                \n\ntypes of trees\n\n\n\n\n                  \n                  Tip\n                  \n                \n\nLook out for very skewed trees like a Linked List\n\n\nTraversals\ntree depth traversals\ntree level order traversal\nTasks\n\n Self-balancing binary trees. donâ€™t forget.\n\n\nQuestions\nQ: Difference between a balanced tree and unbalanced tree?\nTransclude of balanced-vs-unbalanced-trees#balanced-vs-unbalanced\nKey Terms\nTransclude of trees#terms\nRelated Notes\ntree depth traversals\ntree level order traversal\nbinary trees and binary search trees\nSearching &amp; Sorting\nLinked List\nRecursion\ntypes of trees\nReferences(links)\nTree cheatsheet for coding interviews | Tech Interview Handbook\nLeaf It Up To Binary Trees. Most things in software can be brokenâ€¦ | by Vaidehi Joshi | basecs | Medium\nHow To Not Be Stumped By Trees. As soon as the data structure lightbulbâ€¦ | by Vaidehi Joshi | basecs | Medium\nMastering Binary Tree Traversals: A Comprehensive Guide | by Adam DeJans Jr. | Plain Simple Software | Medium"},"ğŸ¥·ğŸ½-jutsus/two-pointers":{"title":"two-pointers","links":["Arrays"],"tags":["zettel","dsa"],"content":"Two-Pointers\nSummary\n\nMoving 2 pointers in a array based on a condition\nUsed when you want to optimise a O(n^2) time â†’ O(n) time and O(n) space â†’ O(1) space.\n\nCharacteristics\n\n2 pointers\nEasy way to decide which pointer to move\nWay to process the array\n\nClassifications\n\nSame Direction: The pointers move in the same direction.\nOpposite Direction: The pointers move in opposite direction.\n\nProblemsâ€¦\n\nPalindrome\n2Sum, 3Sumâ€¦\nLinked Lists\nMultiple Sequences (comparing sequences to find the right one)â†’ Longest word with condition â€¦\nFind 2 elements where conditionâ€¦\nProblems asking for O(1) memory optimisation.\n\n\n\n                  \n                  Info\n                  \n                \n\nSliding Window problems are similar to same direction 2 pointer problems but in sliding window we compute something for the whole window and update it as we add/remove an item from the window, instead of recalculating for the whole window.\n\n\n\nRelated Notes\n\nArrays\n\nReferences(links)\n\nSubarray Sum - Fixed\n"},"ğŸ¥·ğŸ½-jutsus/types-of-graph-edges":{"title":"types of graph edges","links":["ğŸ¥·ğŸ½-jutsus/graphs"],"tags":["zettel","dsa"],"content":"Graph Edges\nCaptures\nWe all know the main type of edges and they are directed and undirected edges. But we also need to know that there are several other types of edges that branch out from these two but have different significance based on the graphs.\nTree edges: are the edges that make sure when you are traversing you reach new node in levels like in trees.\nNon-Tree edges: are the edges that are not tree edges but there can be overlaps depending on the graphs as you know they are not rule-followers.\nUnder non-tree edges we have three main types:\n\nForward edges\nbackward edges\ncross edges\n\nLetâ€™s take an example to help us understand, these edges.\n\nAll the blue edges above are tree edges, you can see that they make a tree if you structure it properly.\nForward edges: green edges are forward edges why? because if you see it in the perspective of the tree edges, u --&gt; x is going forward in the tree.\nBack edges: red edges are back edges why? because again just like forward edges, x --&gt; v is going back in the tree. If you  notice there are also self-loops.\nCross edges: brown edges are cross edges because, cross edges are the edges that connect two subtrees that donâ€™t have common ancestors. here w --&gt; y who are in two different subtrees with no common ancestors.\nThese types apply to both directed and undirected graphs. But undirected graphs can only have tree edges and forward edges.\n\nRelated Notes\ngraphs\nReferences(links)\nSpinning Around In Cycles With Directed Acyclic Graphs | by Vaidehi Joshi | basecs | Medium"},"ğŸ¥·ğŸ½-jutsus/types-of-trees":{"title":"types of trees","links":["ğŸ¥·ğŸ½-jutsus/trees","Interv","ğŸ¥·ğŸ½-jutsus/binary-trees-and-binary-search-trees","ğŸ¥·ğŸ½-jutsus/tree-depth-traversals","ğŸ¥·ğŸ½-jutsus/tree-level-order-traversal"],"tags":["zettel","dsa"],"content":"Types of Trees\nSummary\nWhile trees can be of different shapes and sizes. The most prominent trees we will be working on in coding Interv would be the binary trees and binary search trees.\nTransclude of binary-trees-and-binary-search-trees\n\n\n                  \n                  Tip\n                  \n                \n\nWhen a question involves a BST, the interviewer expects a solution that runs faster than O(n) i.e O(log n)\n\n\n\nRelated Notes\ntrees\ntree depth traversals\ntree level order traversal\nbinary trees and binary search trees\nReferences(links)\nHow To Not Be Stumped By Trees. As soon as the data structure lightbulbâ€¦ | by Vaidehi Joshi | basecs | Medium"}}